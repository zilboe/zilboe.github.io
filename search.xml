<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Linux C】http服务器</title>
      <link href="/2023/09/27/2023-9-27-21-40-11-c-althttp/"/>
      <url>/2023/09/27/2023-9-27-21-40-11-c-althttp/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP服务器-Linux-C"><a href="#HTTP服务器-Linux-C" class="headerlink" title="HTTP服务器 Linux C"></a>HTTP服务器 Linux C</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>公司项目终于整完了，后续由客户提bug我再改了，今天把节能功能加完了，组长还催我提交代码他好继续改板卡的bug，这个月紧张的工作也算是搞定了，有时间闲下来搞Linux了，这次这个代码是我很久之前刷到的一个HTTP服务器的代码，作者是<code>Richard Hipp</code>，不太熟悉是吧？<strong>sqlite数据库</strong>搞嵌入式工作的伙伴应该都熟悉，也就是同一个作者，并且<strong>Althttp</strong>项目是作者最近几年才公开代码，整个Althttp服务器<strong>源代码只有一个c文件，代码量3679行</strong>，里边有http服务，tls，非常适合个人学习，相比nginx来说，对新人更友好，并且作者在代码里边每个部分都有注释，我是做单片机工作的，但是对linux开发也有兴趣，所以，这个文章我会发布与<strong>Althttpd</strong>项目的学习过程，搭配chatgpt一块来学习。</p><h2 id="第一部分：项目介绍"><a href="#第一部分：项目介绍" class="headerlink" title="第一部分：项目介绍"></a>第一部分：项目介绍</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** 2001-09-15</span><br><span class="line">**</span><br><span class="line">** The author disclaims copyright to this source code.  In place of</span><br><span class="line">** a legal notice, here is a blessing:</span><br><span class="line">**</span><br><span class="line">**    May you do good and not evil.</span><br><span class="line">**    May you find forgiveness for yourself and forgive others.</span><br><span class="line">**    May you share freely, never taking more than you give.</span><br><span class="line">**</span><br><span class="line"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span><br><span class="line">**</span><br><span class="line">** This source code file implements a small, simple, stand-alone HTTP</span><br><span class="line">** server.  </span><br><span class="line">**</span><br><span class="line">** Features:</span><br><span class="line">**</span><br><span class="line">**     * Launched from inetd/xinetd/systemd, or as a stand-alone server</span><br><span class="line">**     * One process per request</span><br><span class="line">**     * Deliver static content or run CGI or SCGI</span><br><span class="line">**     * Virtual sites based on the &quot;Host:&quot; property of the HTTP header</span><br><span class="line">**     * Runs in a chroot jail</span><br><span class="line">**     * Unified log file in a CSV format</span><br><span class="line">**     * Small code base (this 1 file) to facilitate security auditing</span><br><span class="line">**     * Simple setup - no configuration files to misconfigure</span><br><span class="line">** </span><br><span class="line">** This file implements a small and simple but secure and effective web</span><br><span class="line">** server.  There are no frills.  Anything that could be reasonably</span><br><span class="line">** omitted has been.</span><br><span class="line">**</span><br><span class="line">** Setup rules:</span><br><span class="line">**</span><br><span class="line">**    (1) Launch as root from inetd/systemd like this:</span><br><span class="line">**</span><br><span class="line">**            althttpd -logfile logfile -root /home/www -user nobody</span><br><span class="line">**</span><br><span class="line">**        It will automatically chroot to /home/www and become user &quot;nobody&quot;.</span><br><span class="line">**        The logfile name should be relative to the chroot jail.</span><br><span class="line">**</span><br><span class="line">**    (2) Directories of the form &quot;<span class="emphasis">*.website&quot; (ex: www_sqlite_org.website)</span></span><br><span class="line"><span class="emphasis">*</span>*        contain content.  The directory is chosen based on the HTTP<span class="emphasis">_HOST</span></span><br><span class="line"><span class="emphasis">**        request header.  If there is no HTTP_</span>HOST header or if the</span><br><span class="line">**        corresponding host directory does not exist, then the</span><br><span class="line">**        &quot;default.website&quot; is used.</span><br><span class="line">**</span><br><span class="line">**        In stand-alone mode (when the --port, --page, or --popup options are</span><br><span class="line">**        used) if neither the HTTP<span class="emphasis">_HOST.website nor &quot;default.website&quot;</span></span><br><span class="line"><span class="emphasis">**        directories exist, then files are served directly from the </span></span><br><span class="line"><span class="emphasis">**        directory from which althttpd was launched.  This makes it easy</span></span><br><span class="line"><span class="emphasis">**        to run a quick web-server for testing purposes using commands like:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**            althttpd --page fiddle.html</span></span><br><span class="line"><span class="emphasis">**            althttpd --popup</span></span><br><span class="line"><span class="emphasis">**            althttpd --port 8080..8090</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**        In one-connection mode (when launched from xinetd or similar)</span></span><br><span class="line"><span class="emphasis">**        an error is raised if &quot;default.website&quot; does not exist.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**        If the HTTP_</span>HOST header contains any charaters other than</span><br><span class="line">**        [a-zA-Z0-9<span class="emphasis">_.,*~/] then a 403 error is generated.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (3) Any file or directory whose name begins with &quot;.&quot; or &quot;-&quot; is ignored,</span></span><br><span class="line"><span class="emphasis">**        except if the URL begins with &quot;/.well-known/&quot; then initial &quot;.&quot; and</span></span><br><span class="line"><span class="emphasis">**        &quot;-&quot; characters are allowed, but not initial &quot;..&quot;.  The exception is</span></span><br><span class="line"><span class="emphasis">**        for RFC-5785 to allow letsencrypt or certbot to generate a TLS cert</span></span><br><span class="line"><span class="emphasis">**        using webroot.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (4) Characters other than [0-9a-zA-Z,-./:_</span>~] and any %HH characters</span><br><span class="line">**        escapes in the filename are all translated into &quot;<span class="emphasis">_&quot;.  This is</span></span><br><span class="line"><span class="emphasis">**        a defense against cross-site scripting attacks and other mischief.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (5) Executable files are run as CGI.  Files whose name ends with &quot;.scgi&quot;</span></span><br><span class="line"><span class="emphasis">**        trigger an SCGI request (see item 9 below).  All other files</span></span><br><span class="line"><span class="emphasis">**        are delivered as is.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (6) If a file named &quot;-auth&quot; exists in the same directory as the file to</span></span><br><span class="line"><span class="emphasis">**        be run as CGI/SCGI or to be delivered, then it contains information</span></span><br><span class="line"><span class="emphasis">**        for HTTP Basic authorization.  See file format details below.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (7) To run as a stand-alone server, simply add the &quot;-port N&quot; command-line</span></span><br><span class="line"><span class="emphasis">**        option to define which TCP port to listen on.  If the argument is</span></span><br><span class="line"><span class="emphasis">**        &quot;--port N1..N2&quot; then TCP ports between N1 and N2 are scanned looking</span></span><br><span class="line"><span class="emphasis">**        for one that is open and the first open port is used.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (8) For static content, the mimetype is determined by the file suffix</span></span><br><span class="line"><span class="emphasis">**        using a table built into the source code below.  If you have</span></span><br><span class="line"><span class="emphasis">**        unusual content files, you might need to extend this table.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (9) Content files that end with &quot;.scgi&quot; and that contain text of the</span></span><br><span class="line"><span class="emphasis">**        form &quot;SCGI hostname port&quot; will format an SCGI request and send it</span></span><br><span class="line"><span class="emphasis">**        to hostname:port, then relay back the reply.  Error behavior is</span></span><br><span class="line"><span class="emphasis">**        determined by subsequent lines of the .scgi file.  See SCGI below</span></span><br><span class="line"><span class="emphasis">**        for details.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**   (10) If compiled with -DENABLE_</span>TLS and linked against OpenSSL and</span><br><span class="line">**        launched with a --cert option to identify a certificate file, then</span><br><span class="line">**        TLS is used to encrypt the connection.</span><br><span class="line">**</span><br><span class="line">** Command-line Options:</span><br><span class="line">**</span><br><span class="line">**  --root DIR       Defines the directory that contains the various</span><br><span class="line">**                   $HOST.website subdirectories, each containing web content </span><br><span class="line">**                   for a single virtual host.  If launched as root and if</span><br><span class="line">**                   &quot;--user USER&quot; also appears on the command-line and if</span><br><span class="line">**                   &quot;--jail 0&quot; is omitted, then the process runs in a chroot</span><br><span class="line">**                   jail rooted at this directory and under the userid USER.</span><br><span class="line">**                   This option is required for xinetd launch but defaults</span><br><span class="line">**                   to &quot;.&quot; for a stand-alone web server.</span><br><span class="line">**</span><br><span class="line">**  --port N         Run in standalone mode listening on TCP port N, or from</span><br><span class="line">**  --port N1..N2    the first available TCP port in the range from N1 to N2.</span><br><span class="line">**</span><br><span class="line">**  --user USER      Define the user under which the process should run if</span><br><span class="line">**                   originally launched as root.  This process will refuse to</span><br><span class="line">**                   run as root (for security).  If this option is omitted and</span><br><span class="line">**                   the process is launched as root, it will abort without</span><br><span class="line">**                   processing any HTTP requests.</span><br><span class="line">**</span><br><span class="line">**  --logfile FILE   Append a single-line, CSV-format, log file entry to FILE</span><br><span class="line">**                   for each HTTP request.  FILE should be a full pathname.</span><br><span class="line">**                   The FILE name is interpreted inside the chroot jail.  The</span><br><span class="line">**                   FILE name is expanded using strftime() if it contains</span><br><span class="line">**                   at least one &#x27;%&#x27; and is not too long.</span><br><span class="line">**</span><br><span class="line">**  --ipshun DIR     If the remote IP address is also the name of a file</span><br><span class="line">**                   in DIR that has size N bytes and where either N is zero</span><br><span class="line">**                   or the m-time of the file is less than N time-units ago</span><br><span class="line">**                   then that IP address is being shunned and no requests</span><br><span class="line">**                   are processed.  The time-unit is a compile-time option</span><br><span class="line">**                   (BANISH<span class="emphasis">_TIME) that defaults to 300 seconds.  If this</span></span><br><span class="line"><span class="emphasis">**                   happens, the client gets a 503 Service Unavailable</span></span><br><span class="line"><span class="emphasis">**                   reply. Furthermore, althttpd will create ip-shunning</span></span><br><span class="line"><span class="emphasis">**                   files following a 404 Not Found error if the request</span></span><br><span class="line"><span class="emphasis">**                   URI is an obvious hack attempt.  The ip-shunning file</span></span><br><span class="line"><span class="emphasis">**                   will also be created if a CGI returns status code 418.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --https BOOLEAN  Indicates that input is coming over SSL and is being</span></span><br><span class="line"><span class="emphasis">**                   decoded upstream, perhaps by stunnel. This option</span></span><br><span class="line"><span class="emphasis">**                   does *not* activate built-in TLS support.  Use --cert</span></span><br><span class="line"><span class="emphasis">**                   for that.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --page NAME      Come up in stand-alone mode, and then try to launch a</span></span><br><span class="line"><span class="emphasis">**                   web-browser pointing to the NAME document after the</span></span><br><span class="line"><span class="emphasis">**                   listening socket has been created.  This option</span></span><br><span class="line"><span class="emphasis">**                   implies --loopback and &quot;--port 8080..8100&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --popup          Launch a stand-alone web server to use for testing.</span></span><br><span class="line"><span class="emphasis">**                   This option implies &quot;--port 8080..8100&quot;.  This option</span></span><br><span class="line"><span class="emphasis">**                   is similar to &quot;--page NAME&quot; except that it does not</span></span><br><span class="line"><span class="emphasis">**                   try to launch a web-browser and does not force the</span></span><br><span class="line"><span class="emphasis">**                   connection into --loopback mode.  Use this when</span></span><br><span class="line"><span class="emphasis">**                   running a test web-server on a remote host via ssh.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --loopback       Only accept loop-back TCP connections (connections</span></span><br><span class="line"><span class="emphasis">**                   originating from the same host).  This is the</span></span><br><span class="line"><span class="emphasis">**                   default if --root is omitted.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --family ipv4    Only accept input from IPV4 or IPV6, respectively.</span></span><br><span class="line"><span class="emphasis">**  --family ipv6    These options are only meaningful if althttpd is run</span></span><br><span class="line"><span class="emphasis">**                   as a stand-alone server.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --jail BOOLEAN   Indicates whether or not to form a chroot jail if </span></span><br><span class="line"><span class="emphasis">**                   initially run as root.  The default is true, so the only</span></span><br><span class="line"><span class="emphasis">**                   useful variant of this option is &quot;--jail 0&quot; which prevents</span></span><br><span class="line"><span class="emphasis">**                   the formation of the chroot jail.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --max-age SEC    The value for &quot;Cache-Control: max-age=%d&quot;.  Defaults to</span></span><br><span class="line"><span class="emphasis">**                   120 seconds.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --max-cpu SEC    Maximum number of seconds of CPU time allowed per</span></span><br><span class="line"><span class="emphasis">**                   HTTP connection.  Default 30 (build option:</span></span><br><span class="line"><span class="emphasis">**                   -DMAX_</span>CPU=integer). 0 means no limit.</span><br><span class="line">**</span><br><span class="line">**  --debug BOOLEAN  Disables input timeouts.  This is useful for debugging</span><br><span class="line">**                   when inputs are being typed in manually.</span><br><span class="line">**</span><br><span class="line">**  --enable-sab     Add new lines to the HTTP reply header that are</span><br><span class="line">**                   prerequisites for SharedArrayBuffer.  These are the lines:</span><br><span class="line">**                     Cross-Origin-Embedder-Policy: require-corp</span><br><span class="line">**                     Cross-Origin-Opener-Policy: same-origin</span><br><span class="line">**        </span><br><span class="line">**</span><br><span class="line">** Additional command-line options available when compiling with ENABLE<span class="emphasis">_TLS:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --cert FILE      The TLS certificate, the &quot;fullchain.pem&quot; file</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --pkey FILE      The TLS private key, the &quot;privkey.pem&quot; file.  May be</span></span><br><span class="line"><span class="emphasis">**                   omitted if the --cert file is the concatenation of</span></span><br><span class="line"><span class="emphasis">**                   the fullchain.pem and the privkey.pem.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Command-line options can take either one or two initial &quot;-&quot; characters.</span></span><br><span class="line"><span class="emphasis">** So &quot;--debug&quot; and &quot;-debug&quot; mean the same thing, for example.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Security Features:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (1)  This program automatically puts itself inside a chroot jail if</span></span><br><span class="line"><span class="emphasis">**      it can and if not specifically prohibited by the &quot;--jail 0&quot;</span></span><br><span class="line"><span class="emphasis">**      command-line option.  The root of the jail is the directory that</span></span><br><span class="line"><span class="emphasis">**      contains the various $HOST.website content subdirectories.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (2)  No input is read while this process has root privileges.  Root</span></span><br><span class="line"><span class="emphasis">**      privileges are dropped prior to reading any input (but after entering</span></span><br><span class="line"><span class="emphasis">**      the chroot jail, of course).  If root privileges cannot be dropped</span></span><br><span class="line"><span class="emphasis">**      (for example because the --user command-line option was omitted or</span></span><br><span class="line"><span class="emphasis">**      because the user specified by the --user option does not exist), </span></span><br><span class="line"><span class="emphasis">**      then the process aborts with an error prior to reading any input.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (3)  The length of an HTTP request is limited to MAX_</span>CONTENT<span class="emphasis">_LENGTH bytes</span></span><br><span class="line"><span class="emphasis">**      (default: 250 million).  Any HTTP request longer than this fails</span></span><br><span class="line"><span class="emphasis">**      with an error. (Build option: -DMAX_</span>CONTENT<span class="emphasis">_LENGTH=integer)</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (4)  There are hard-coded time-outs on each HTTP request.  If this process</span></span><br><span class="line"><span class="emphasis">**      waits longer than the timeout for the complete request, or for CGI</span></span><br><span class="line"><span class="emphasis">**      to finish running, then this process aborts.  (The timeout feature</span></span><br><span class="line"><span class="emphasis">**      can be disabled using the --debug command-line option.)</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (5)  If the HTTP_</span>HOST request header contains characters other than</span><br><span class="line">**      [0-9a-zA-Z,-./:<span class="emphasis">_~] then the entire request is rejected.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (6)  Any characters in the URI pathname other than [0-9a-zA-Z,-./:_</span>~]</span><br><span class="line">**      are converted into &quot;<span class="emphasis">_&quot;.  This applies to the pathname only, not</span></span><br><span class="line"><span class="emphasis">**      to the query parameters or fragment.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (7)  If the first character of any URI pathname component is &quot;.&quot; or &quot;-&quot;</span></span><br><span class="line"><span class="emphasis">**      then a 404 Not Found reply is generated.  This prevents attacks</span></span><br><span class="line"><span class="emphasis">**      such as including &quot;..&quot; or &quot;.&quot; directory elements in the pathname</span></span><br><span class="line"><span class="emphasis">**      and allows placing files and directories in the content subdirectory</span></span><br><span class="line"><span class="emphasis">**      that are invisible to all HTTP requests, by making the first </span></span><br><span class="line"><span class="emphasis">**      character of the file or subdirectory name &quot;-&quot; or &quot;.&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (8)  The request URI must begin with &quot;/&quot; or else a 404 error is generated.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (9)  This program never sets the value of an environment variable to a</span></span><br><span class="line"><span class="emphasis">**      string that begins with &quot;() &#123;&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (10) If the --ipshun option is used, specific IP addresses can be</span></span><br><span class="line"><span class="emphasis">**      temporarily block for abusive behavior.  </span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (11) If a CGI reports status code 418 (&quot;I&#x27;m a teapot&quot;, rfc2324) and if</span></span><br><span class="line"><span class="emphasis">**      the --ipshun option is used, then the IP address is temporarily</span></span><br><span class="line"><span class="emphasis">**      blocked.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Security Auditing:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** This webserver mostly only serves static content.  Any security risk will</span></span><br><span class="line"><span class="emphasis">** come from CGI and SCGI.  To check an installation for security, then, it</span></span><br><span class="line"><span class="emphasis">** makes sense to focus on the CGI and SCGI scripts.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** To locate all CGI files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          find *.website -executable -type f -print</span></span><br><span class="line"><span class="emphasis">**     OR:  find *.website -perm +0111 -type f -print</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** The first form of the &quot;find&quot; command is preferred, but is only supported</span></span><br><span class="line"><span class="emphasis">** by GNU find.  On a Mac, you&#x27;ll have to use the second form.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** To find all SCGI files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          find *.website -name &#x27;*.scgi&#x27; -type f -print</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** If any file is a security concern, it can be disabled on a live</span></span><br><span class="line"><span class="emphasis">** installation by turning off read permissions:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          chmod 0000 file-of-concern</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** SCGI Specification Files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Content files (files without the execute bit set) that end with &quot;.scgi&quot;</span></span><br><span class="line"><span class="emphasis">** specify a connection to an SCGI server.  The format of the .scgi file</span></span><br><span class="line"><span class="emphasis">** follows this template:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**      SCGI hostname port</span></span><br><span class="line"><span class="emphasis">**      fallback: fallback-filename</span></span><br><span class="line"><span class="emphasis">**      relight: relight-command</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** The first line specifies the location and TCP/IP port of the SCGI</span></span><br><span class="line"><span class="emphasis">** server that will handle the request.  Subsequent lines determine</span></span><br><span class="line"><span class="emphasis">** what to do if the SCGI server cannot be contacted.  If the</span></span><br><span class="line"><span class="emphasis">** &quot;relight:&quot; line is present, then the relight-command is run using</span></span><br><span class="line"><span class="emphasis">** system() and the connection is retried after a 1-second delay.  Use</span></span><br><span class="line"><span class="emphasis">** &quot;&amp;&quot; at the end of the relight-command to run it in the background.</span></span><br><span class="line"><span class="emphasis">** Make sure the relight-command does not generate output, or that</span></span><br><span class="line"><span class="emphasis">** output will become part of the SCGI reply.  Add a &quot;&gt;/dev/null&quot;</span></span><br><span class="line"><span class="emphasis">** suffix (before the &quot;&amp;&quot;) to the relight-command if necessary to</span></span><br><span class="line"><span class="emphasis">** suppress output.  If there is no relight-command, or if the relight</span></span><br><span class="line"><span class="emphasis">** is attempted but the SCGI server still cannot be contacted, then</span></span><br><span class="line"><span class="emphasis">** the content of the fallback-filename file is returned as a</span></span><br><span class="line"><span class="emphasis">** substitute for the SCGI request.  The mimetype is determined by the</span></span><br><span class="line"><span class="emphasis">** suffix on the fallback-filename.  The fallback-filename would</span></span><br><span class="line"><span class="emphasis">** typically be an error message indicating that the service is</span></span><br><span class="line"><span class="emphasis">** temporarily unavailable.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Basic Authorization:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** If the file &quot;-auth&quot; exists in the same directory as the content file</span></span><br><span class="line"><span class="emphasis">** (for both static content and CGI) then it contains the information used</span></span><br><span class="line"><span class="emphasis">** for basic authorization.  The file format is as follows:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    *  Blank lines and lines that begin with &#x27;#&#x27; are ignored</span></span><br><span class="line"><span class="emphasis">**    *  &quot;http-redirect&quot; forces a redirect to HTTPS if not there already</span></span><br><span class="line"><span class="emphasis">**    *  &quot;https-only&quot; disallows operation in HTTP</span></span><br><span class="line"><span class="emphasis">**    *  &quot;user NAME LOGIN:PASSWORD&quot; checks to see if LOGIN:PASSWORD </span></span><br><span class="line"><span class="emphasis">**       authorization credentials are provided, and if so sets the</span></span><br><span class="line"><span class="emphasis">**       REMOTE_</span>USER to NAME.</span><br><span class="line">**    *  &quot;realm TEXT&quot; sets the realm to TEXT.</span><br><span class="line">**</span><br><span class="line">** There can be multiple &quot;user&quot; lines.  If no &quot;user&quot; line matches, the</span><br><span class="line">** request fails with a 401 error.</span><br><span class="line">**</span><br><span class="line">** Because of security rule (7), there is no way for the content of the &quot;-auth&quot;</span><br><span class="line">** file to leak out via HTTP request.</span><br><span class="line"><span class="emphasis">*/</span></span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>作者代码开篇介绍的是该项目的功能：</p><p> 1.可以通过<strong>inetd</strong>、<strong>xinetd</strong>或<strong>systemd</strong>启动，也可以作为一个独立的服务器启动。</p><p> 2.每个请求都有一个独立的进程来处理：每个客户端请求都有一个独立进程来处理，隔离了不同的请求，保证安全性</p><p> 3.可以提供静态文件内容，也可以运行CGI或SCGI脚本，来生成动态内容</p><p> 4.支持HTTP请求中头中“Host”虚拟主机的标示，可以为不同的主机名提供不同的内容，意味着多个域名可以共享一个主机</p><p> 5.服务器运行在<strong>chroot</strong>环境中，意味着被限制在一个特定的目录中，增加了安全性</p><p> 6.服务器生成统一的日志文件，<strong>CSV</strong>格式文件</p><p> 7.服务器代码非常小，仅仅由一个文件组成，对代码进行评审会非常容易</p><p> 8.配置简单，没有复杂的配置文件来配置，降低了配置错误的可能性，服务器也方便维护。</p><h3 id="Althttp设置规则"><a href="#Althttp设置规则" class="headerlink" title="Althttp设置规则"></a>Althttp设置规则</h3><p>1.可以作为 <code>root</code> 用户从 <strong>inetd</strong> 或 <strong>systemd</strong> 启动。通过命令行参数指定日志文件 <strong>-logfile</strong>，根目录 <strong>-root</strong>，和用户 <strong>-user</strong>。服务器将自动在 <strong>-root</strong> 目录下进行 <strong>chroot</strong> 操作，并切换到指定的用户（在这个例子中是 “<strong>nobody</strong>“ 用户）。日志文件的名称应该是相对于 chroot 环境的路径。</p><p>2.目录名称以 “*.website” 格式表示（例如：www_sqlite_org.website），包含网站内容。服务器将根据 HTTP 请求头中的 “Host:” 属性选择对应的目录。如果没有 HTTP 请求头中的 “Host:” 属性，或者对应的主机目录不存在，那么将使用 “default.website” 目录。在独立模式下，如果既没有 HTTP_HOST.website 目录，也没有 “default.website” 目录，则直接从启动 althttpd 的目录中提供文件。这使得可以轻松地用于测试目的。</p><p>3.文件或目录名称以 “.” 或 “-“ 开头的将被忽略，但如果 URL 以 “&#x2F;.well-known&#x2F;“ 开头，则允许初始的 “.” 和 “-“ 字符，但不允许初始的 “..”。这是为了允许 <strong>RFC-5785</strong> 支持，以便 <strong>letsencrypt</strong> 或 <strong>certbot</strong> 可以使用 webroot 生成 TLS 证书。</p><p>4.文件名中除了 [0-9a-zA-Z,-.&#x2F;:~] 和 %HH 字符转义之外的所有字符都被翻译为下划线。这是为了防止跨站脚本攻击等安全问题。</p><p>5.可执行文件将作为 CGI 运行。文件名以 “<strong>.scgi</strong>“ 结尾的触发 <strong>SCGI</strong> 请求，其他文件直接传递。</p><p>6.如果在与要作为 <strong>CGI&#x2F;SCGI</strong> 运行或传递的文件相同的目录中存在一个名为 “<strong>-auth</strong>“ 的文件，则它包含了 HTTP 基本认证的信息。文件格式的详细信息在下文中提供。</p><p>7.要以独立服务器运行，只需添加 “<strong>-port N</strong>“ 命令行选项，以定义要监听的 TCP 端口。如果参数是 “<strong>–port N1..N2</strong>“，则将扫描介于 N1 和 N2 之间的 TCP 端口，找到第一个空闲的端口并使用它。</p><p>8.对于静态内容，服务器通过文件后缀来确定 <strong>MIME</strong> 类型，使用内置在源代码中的表。如果有不常见的内容文件，可能需要扩展此表。</p><p>9.以 “<strong>.scgi</strong>“ 结尾的内容文件，如果包含 “<strong>SCGI hostname port</strong>“格式的文本，将格式化 <strong>SCGI</strong> 请求并发送到 <strong>hostname:port</strong>，然后中继回复。错误行为由”<strong>.scgi</strong>“文件的后续行确定。</p><p>10.如果使用<code>-DENABLE_TLS</code>编译选项并链接到 OpenSSL，并使用 <code>--cert</code> 选项启动以指定证书文件，则将使用 <code>TLS</code> 加密连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode】2.两数相加-C</title>
      <link href="/2023/09/11/2023-8-20-13-01-19-c-leetcode2/"/>
      <url>/2023/09/11/2023-8-20-13-01-19-c-leetcode2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p><strong>题目</strong> ：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg"></p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</p><p>输出：[7,0,8]</p><p>解释：342 + 465 &#x3D; 807.</p><p><strong>示例 2：</strong></p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]</p><p>输出：[0]</p><p><strong>示例 3：</strong></p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</p><p>输出：[8,9,9,9,0,0,0,1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="comment">//创建head和tail指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span>=</span><span class="literal">NULL</span>,*tail=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//记录两个值相加的进位</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(l1 || l2)&#123;    <span class="comment">//l1,l2不都为空</span></span><br><span class="line">        <span class="type">int</span> n1 = l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n2 = l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = n1 + n2 + count;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="comment">//节点为空,头和尾同时置一下</span></span><br><span class="line">            head = tail = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail-&gt;val = sum % <span class="number">10</span>;   <span class="comment">//取余数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已经有头节点，尾节点的下一个开辟空间</span></span><br><span class="line">            tail-&gt;next = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;val = sum % <span class="number">10</span>;  <span class="comment">//取余数</span></span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        count = sum / <span class="number">10</span>;   <span class="comment">//count取进位</span></span><br><span class="line">        <span class="comment">//l1和l2两个链表向后移动</span></span><br><span class="line">        <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count != <span class="number">0</span>)  <span class="comment">//count不为0，最后一个节点有进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        tail-&gt;val = count;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/note/note8.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】5. 最长回文子串-C</title>
      <link href="/2023/09/10/2023-9-10-16-3A22-3A58-c-leetcode5/"/>
      <url>/2023/09/10/2023-9-10-16-3A22-3A58-c-leetcode5/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><hr><p><strong>示例 1：</strong></p><p><strong>输入：</strong><br>s &#x3D; “babad”</p><p><strong>输出：</strong>“bab”</p><p><strong>解释：</strong>“aba” 同样是符合题意的答案。</p><hr><p><strong>示例 2：</strong></p><p><strong>输入：</strong><br>s &#x3D; “cbbd”</p><p><strong>输出：</strong>“bb”</p><hr><hr><p><strong>提示：</strong></p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</p><p>s 仅由数字和英文字母组成</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】4.寻找两个正序数组的中位数-C</title>
      <link href="/2023/09/05/2023-9-05-12-11-16-c-leetcode4/"/>
      <url>/2023/09/05/2023-9-05-12-11-16-c-leetcode4/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h1><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><h2 id="算法的时间复杂度应该为-O-log-m-n-。"><a href="#算法的时间复杂度应该为-O-log-m-n-。" class="headerlink" title="算法的时间复杂度应该为 O(log (m+n)) 。"></a>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</h2><p><code>示例 1：</code></p><p><strong>输入：</strong>nums1 &#x3D; [1,3], nums2 &#x3D; [2]</p><p><strong>输出：</strong>2.00000</p><p><strong>解释：</strong>合并数组 &#x3D; [1,2,3] ，中位数 2</p><hr><hr><p><code>示例 2：</code></p><p><strong>输入：</strong>nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</p><p><strong>输出：</strong>2.50000</p><p><strong>解释：</strong>合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><hr><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>两个数组是正序排序的，可以将两个数组合并到一个数组里，然后判断数组长度是不是<code>2</code>的倍数，如果是<strong>取中间两个数之和除以2</strong>，不是的话<strong>直接取中间数</strong>进行返回就行了。</p><p>所以这么写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *n = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(nums1Size+nums2Size));</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums1Size &amp;&amp; j&lt;nums2Size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两个数组都有数据,依照正序存到n数组中</span></span><br><span class="line">        n[nSize++] = nums1[i]&lt;nums2[j]?nums1[i++]:nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums1Size)  <span class="comment">//num1还有数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        n[nSize++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums2Size)  <span class="comment">//num2还有数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        n[nSize++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nSize%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//判断长度奇偶</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//偶数取中间两数之和/2</span></span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">float</span>)n[nSize<span class="number">-1</span>]+(<span class="type">float</span>)n[nSize])/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//奇数直接取中间值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(n[nSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】3.无重复字符的最长子串-C</title>
      <link href="/2023/08/28/2023-8-28-12-15-20-c-leetcode3/"/>
      <url>/2023/08/28/2023-8-28-12-15-20-c-leetcode3/</url>
      
        <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a><strong>示例1：</strong></h2><p><strong>输入:</strong> s &#x3D; “abcabcbb”</p><p><strong>输出:</strong> 3 </p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><hr><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a><strong>示例2：</strong></h2><p><strong>输入:</strong> s &#x3D; “bbbbb”</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><hr><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a><strong>示例3：</strong></h2><p><strong>输入:</strong> s &#x3D; “pwwkew”</p><p><strong>输出:</strong> 3</p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><hr><p><strong>提示：</strong></p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</p><p>s 由英文字母、数字、符号和空格组成</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>这个题抓住最主要的就能通透理解了，<strong>s 是由字符串组成</strong>，说明不管s的长度有多长，他都是ascii码组成，ascii码总共有<strong>127</strong>个，所以他最大无重复字符串长度也就最多是127个。</p><p>我们只需要使用一个128空间长度的表来存这些ascii码就足够了。</p><p>使用<strong>滑动窗口</strong>的方法，用到左指针和右指针，右指针专门来遍历<code>s</code>字符串，左指针来控制我们的<code>map</code>，也就是我们自己的一个数据表。</p><p><code>思路</code>是：右指针不停的向右遍历<code>s</code>字符串，当我们发现<code>map</code>表中没有这个元素，我们就<strong>存进去</strong>，如果发现<code>右指针</code>的元素在当前的表中<strong>存在</strong>，那我们将<code>左指针</code>一直向右移动，直到<code>左指针</code>跑到和当前元素相等的位置，在此基础上，把<strong>map表</strong>左指针遍历过的<code>值</code>全部移除(包括相等的那个值)，这样，我们的<code>map表长度</code>不会超过最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>1.定义一个map表描述</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MAX_LENGTH  128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAP_MAX_LENGTH];</span><br><span class="line">    <span class="type">__uint8_t</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.判断map表中是否有无相等元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断表中是否右相等元素数据</span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-不存在，1-存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">isExtData</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">map</span>-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">__uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="built_in">map</span>-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>-&gt;data[i]==ch)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.向map表中插入数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向map表插入数据</span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-成功，1-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">insertDataToMap</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断表中有无数据</span></span><br><span class="line">    <span class="keyword">if</span>(isExtData(<span class="built_in">map</span>,ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//存在数据直接返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>-&gt;data[<span class="built_in">map</span>-&gt;length++] = ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//存进表中返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.从map表中移除数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从map表中移除数据 </span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-成功，1-失败(其实无所谓了这里)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">removeDataFromMap</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isExtData(<span class="built_in">map</span>,ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">__uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="built_in">map</span>-&gt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>-&gt;data[i]==ch)<span class="comment">//找到元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">__uint8_t</span> j=i;j&lt;<span class="built_in">map</span>-&gt;length<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>-&gt;data[j]=<span class="built_in">map</span>-&gt;data[j+<span class="number">1</span>];<span class="comment">//把数据向前搬移一位</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>-&gt;length-=<span class="number">1</span>;<span class="comment">//同时让表长度-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.获取最长字串的长度</strong></p><p>结合上边我们的三个辅助函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="comment">//创建表，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">map</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">map</span>.data,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>.data));</span><br><span class="line">    <span class="built_in">map</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义左右指针，记录当前长度length和最大长度maxLength</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,length=<span class="number">0</span>,maxLength=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//窗口的右指针为边界</span></span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="built_in">strlen</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断右指针的值是否在map中，如果不存在，将元素添加到map中，然后length+1，右指针向右移动，</span></span><br><span class="line">        <span class="comment">//然后用maxlength记录最大的length值</span></span><br><span class="line">        <span class="keyword">if</span>(isExtData(&amp;<span class="built_in">map</span>,s[right]))</span><br><span class="line">        &#123;</span><br><span class="line">           insertDataToMap(&amp;<span class="built_in">map</span>,s[right]);</span><br><span class="line">           length+=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(length &gt; maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">           &#125;</span><br><span class="line">           right+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右指针元素在map中存在，说明滑动区间存在两个相同的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当右指针元素的值存在map时，我们移除map中左指针的值，然后将左指针向右移动一个单位，length相应的要减一</span></span><br><span class="line">            <span class="keyword">while</span>(!isExtData(&amp;<span class="built_in">map</span>,s[right]))&#123;</span><br><span class="line">                removeDataFromMap(&amp;<span class="built_in">map</span>,s[left]);</span><br><span class="line">                left+=<span class="number">1</span>;</span><br><span class="line">                length-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上述while结束或者map中不存在左指针值，说明map中又是无重复的元素，那我们继续添加右指针值，</span></span><br><span class="line">            <span class="comment">//然后长度加一，右指针继续向右移动，</span></span><br><span class="line">            insertDataToMap(&amp;<span class="built_in">map</span>,s[right]);</span><br><span class="line">            length+=<span class="number">1</span>;</span><br><span class="line">            right+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode每日一题】2236-判断很节点是否等于子节点之和</title>
      <link href="/2023/08/20/2023-8-20-21-56-50-leetcode2236/"/>
      <url>/2023/08/20/2023-8-20-21-56-50-leetcode2236/</url>
      
        <content type="html"><![CDATA[<h1 id="2236-判断很节点是否等于子节点之和"><a href="#2236-判断很节点是否等于子节点之和" class="headerlink" title="2236-判断很节点是否等于子节点之和"></a>2236-判断很节点是否等于子节点之和</h1><p>给你一个 <strong>二叉树</strong> 的根结点 <code>root</code>，该二叉树由恰好 3 个结点组成：<code>根结点</code>、<code>左子结点</code>和<code>右子结点</code>。</p><p>如果根结点值等于两个子结点值之和，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png"></p><hr><p>输入：root &#x3D; [10,4,6]</p><p>输出：true</p><p>解释：根结点、左子结点和右子结点的值分别是 10 、4 和 6 。<br>由于 10 等于 4 + 6 ，因此返回 true 。</p><hr><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png"></p><hr><p>输入：root &#x3D; [5,3,1]</p><p>输出：false</p><p>解释：根结点、左子结点和右子结点的值分别是 5 、3 和 1 。由于 5 不等于 3 + 1 ，因此返回 false</p><hr><hr><p><strong>提示：</strong></p><p>树只包含根结点、左子结点和右子结点</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><hr><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>这题没有难度，直接就是一个判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">checkTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root-&gt;val == (root-&gt;left-&gt;val+root-&gt;right-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/note/note7.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【c语言数据结构】</title>
      <link href="/2023/08/12/2023-8-12-17-12-25-list-arr/"/>
      <url>/2023/08/12/2023-8-12-17-12-25-list-arr/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言数据结构"><a href="#c语言数据结构" class="headerlink" title="c语言数据结构"></a>c语言数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放数据的一串连续的空间，它的声明是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果你不想定义空间长度可以这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>这样如果在后续运算的过程中我们要用到它的长度，你可以这样</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr_len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>它的意思就是整个,<strong>整个数组空间大小&#x2F;数组单个空间大小</strong>，得到我们的数组长度。可以将它定义为<code>宏</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_SIZE(x)(sizeof(x)/sizeof(x[0]))</span></span><br></pre></td></tr></table></figure><p>这样在写代码过程中直接调用<code>ARR_SIZE</code>，向里边传递数组就可以得到数组长度。</p><p>数组在空间上是连续的，我们可以通过下标来获取指定位置的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_SIZE(x)(sizeof(x)/sizeof(x[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="type">int</span> a3 = arr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下标从<code>0</code>开始。所以我们<code>a3</code>得到的值是<strong>arr</strong>数组第三个值<code>3</code>。</p><p>优点：从数组中获取数据，它的时间复杂度是<code>O(1)</code>，是最快的。</p><p>缺点：数据空间长度必须明确，以防止我们存储或者获取数据时不会出现越界。</p><p><strong>以上按照顺序表来举例</strong></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><code>顺序表</code>就是由数组来构成的，就像名称一样，它的数据排布是按顺序来构成的，中间也尽量不留空。但是有一个缺点，<strong>顺序表的长度是需要提前设定好的，这可以根据我们要安排存储的数据大小来提前设定好顺序表长度</strong></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>链表就是通过指针来将多个数据绑定到一块，他们在内存上分布一般是不会连续的，所以通过<code>指针</code>来将这些数据串联起来。</p><p>组成：将数据整理成节点，然后这些节点通过指针连接起来，最后只需要一个头节点的地址，我们就能访问整个链表所有的节点数据。</p><p>例子：创建一个节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br></pre></td></tr></table></figure><p>以上就是一个链表节点的例子，但是通常情况下，我个人不习惯这样用，因为<strong>我们既然都用链表了，如果这个链表提供给我们的信息太少，那对于链表的节点的查找和存储相比较更麻烦，比如说你不记录这个链表的长度，你怎么知道这个链表到底有没有节点。链表内部的节点到底有多少。</strong>所以我个人一般这样制作一个链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br></pre></td></tr></table></figure><p>在链表节点外再套一层框架，能够记录当前链表的一些信息，比如长度，或者链表的可用性<code>加锁</code>之类的。</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">t_list <span class="built_in">list</span>;<span class="comment">//定义链表变量</span></span><br><span class="line">    <span class="built_in">list</span>.listSize = <span class="number">0</span>;<span class="comment">//节点数为0</span></span><br><span class="line">    <span class="built_in">list</span>.node = <span class="literal">NULL</span>;<span class="comment">//第一个节点不存在，为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点并添加data数据"><a href="#创建节点并添加data数据" class="headerlink" title="创建节点并添加data数据"></a>创建节点并添加data数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line">t_list_node *<span class="title function_">addDataToNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请一块节点大小的内存</span></span><br><span class="line">    t_list_node *node = (t_list_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(t_list_node));</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建节点失败，内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点创建完毕而且数据存储的为data</p><h3 id="向链表加入节点-尾插（尾插会了头插你也会了）"><a href="#向链表加入节点-尾插（尾插会了头插你也会了）" class="headerlink" title="向链表加入节点(尾插（尾插会了头插你也会了）)"></a>向链表加入节点(尾插（尾插会了头插你也会了）)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 把节点插入链表(尾插法)</span></span><br><span class="line"><span class="comment"> * @param list 插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 插入的节点</span></span><br><span class="line"><span class="comment"> * @return 返回链表当前长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listAddNode</span><span class="params">(t_list *<span class="built_in">list</span>,t_list_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">list</span> || !node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;<span class="comment">//用pList来控制list</span></span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="comment">//可以先进行链表长度的判断</span></span><br><span class="line">    <span class="keyword">if</span>(pList-&gt;listSize == <span class="number">0</span>)<span class="comment">//不存在节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pList-&gt;node = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(;pNode-&gt;next != <span class="literal">NULL</span>;pNode = pNode-&gt;next);</span><br><span class="line">        pNode-&gt;next = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表插入就结束了。</p><h3 id="删除链表中某个节点，删除数据为data的节点-假设链表只有一个该data节点"><a href="#删除链表中某个节点，删除数据为data的节点-假设链表只有一个该data节点" class="headerlink" title="删除链表中某个节点，删除数据为data的节点(假设链表只有一个该data节点)"></a>删除链表中某个节点，删除数据为data的节点(假设链表只有一个该data节点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteDataNodeFromList</span><span class="params">(t_list *<span class="built_in">list</span>, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;</span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空,删除失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">1</span>) <span class="comment">// 节点只有一个，判断是不是data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data != data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pNode);</span><br><span class="line">            pNode = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *pDele = <span class="literal">NULL</span>;<span class="comment">//定义一个删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//走到这里表示链表长度大于0，并且第一个节点就是要删除的</span></span><br><span class="line">        pDele = pNode;<span class="comment">//删除节点指向第一个节点</span></span><br><span class="line">        pNode = pNode-&gt;next; <span class="comment">//把第二个节点换成第一个节点</span></span><br><span class="line">        pList-&gt;node = pNode;<span class="comment">//重新给链表指向第一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(pDele);<span class="comment">//释放这个删除节点</span></span><br><span class="line">        pDele = <span class="literal">NULL</span>;<span class="comment">//指针置空</span></span><br><span class="line">        pList-&gt;listSize -= <span class="number">1</span>;<span class="comment">//长度-1</span></span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;<span class="comment">//返回长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//第一个不是data的节点</span></span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pNode的下一个节点不是空,进入循环</span></span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;next-&gt;data == data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//发现下一个节点的数据域为data，我们要删除的节点为下一个节点</span></span><br><span class="line">                pDele = pNode-&gt;next;<span class="comment">//删除节点指向下一个节点</span></span><br><span class="line">                pNode-&gt;next = pDele-&gt;next;<span class="comment">//将下一个节点的下一个过继到当前节点的下一个</span></span><br><span class="line">                <span class="built_in">free</span>(pDele);<span class="comment">//释放删除节点</span></span><br><span class="line">                pDele = <span class="literal">NULL</span>;<span class="comment">//置空</span></span><br><span class="line">                pList-&gt;listSize -= <span class="number">1</span>;<span class="comment">//长度-1</span></span><br><span class="line">                <span class="keyword">return</span> pList-&gt;listSize;<span class="comment">//返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个数据域不为data,pNode后移</span></span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后返回链表长度</span></span><br><span class="line">    <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除节点就做到这里</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="comment">// 创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个节点的指针</span></span><br><span class="line">&#125; t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> listSize;      <span class="comment">// 当前链表长度</span></span><br><span class="line">    t_list_node *node; <span class="comment">// 链表的第一个节点</span></span><br><span class="line">&#125; t_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建节点并存储data</span></span><br><span class="line"><span class="comment"> * @param data 存储数据</span></span><br><span class="line"><span class="comment"> * @return 返回节点地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t_list_node *<span class="title function_">addDataToNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 申请一块节点大小的内存</span></span><br><span class="line">    t_list_node *node = (t_list_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(t_list_node));</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建节点失败，内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 把节点插入链表(尾插法)</span></span><br><span class="line"><span class="comment"> * @param list 插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 插入的节点</span></span><br><span class="line"><span class="comment"> * @return 返回链表当前长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listAddNode</span><span class="params">(t_list *<span class="built_in">list</span>, t_list_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list</span> || !node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>; <span class="comment">// 用pList来控制list</span></span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="comment">// 可以先进行链表长度的判断</span></span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>) <span class="comment">// 不存在节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pList-&gt;node = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (; pNode-&gt;next != <span class="literal">NULL</span>; pNode = pNode-&gt;next)</span><br><span class="line">            ;</span><br><span class="line">        pNode-&gt;next = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteDataNodeFromList</span><span class="params">(t_list *<span class="built_in">list</span>, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;</span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空,删除失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">1</span>) <span class="comment">// 节点只有一个，判断是不是data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data != data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pNode);</span><br><span class="line">            pNode = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *pDele = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">        pDele = pNode;</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">        pList-&gt;node = pNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(pDele);</span><br><span class="line">        pDele = <span class="literal">NULL</span>;</span><br><span class="line">        pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;next-&gt;data == data)</span><br><span class="line">            &#123;</span><br><span class="line">                pDele = pNode-&gt;next;</span><br><span class="line">                pNode-&gt;next = pDele-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(pDele);</span><br><span class="line">                pDele = <span class="literal">NULL</span>;</span><br><span class="line">                pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    t_list <span class="built_in">list</span>;       <span class="comment">// 定义链表变量</span></span><br><span class="line">    <span class="built_in">list</span>.listSize = <span class="number">0</span>; <span class="comment">// 节点数为0</span></span><br><span class="line">    <span class="built_in">list</span>.node = <span class="literal">NULL</span>;  <span class="comment">// 第一个节点不存在，为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_list_node *node = addDataToNode(i);</span><br><span class="line">        listAddNode(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *p = <span class="built_in">list</span>.node;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listsize = deleteDataNodeFromList(&amp;<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (listsize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无节点\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">list</span>.node;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码是向链表中加入了<code>1-10</code>个数字，然后打印一边结果，最后删除data为5的节点，再次执行打印结果</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>着重讲<code>链表</code>是因为链表比较锻炼思维，在编程里就是靠这些思维来实现代码，能让人更方便开发具有逻辑性的代码和功能。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表就是如图所示</p><p><img src="/pic/note/note4.jpg"></p><p><code>双向链表</code>对于单链表来说只是多了一条链路，连接当前节点的前一个节点。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种树状数据结构，每个节点最多包含两个子节点，<code>根节点</code>就是二叉树的顶部节点，是树的起点，</p><p>从起点开始向下延申，连接其他的节点。</p><p><code>叶子节点</code>，没有子节点的节点，位于树的末端。<code>子树</code>就是每个节点可以看成一个子树的根，包括它自己以及它的所有子节点，这些子树也是二叉树。</p><p><code>二叉树的遍历</code>：分为前序、中序、后序遍历。不同的遍历方式节点的顺序不同。</p><h3 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树节点创建"><a href="#二叉树节点创建" class="headerlink" title="二叉树节点创建"></a>二叉树节点创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点插入二叉树"><a href="#节点插入二叉树" class="headerlink" title="节点插入二叉树"></a>节点插入二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> TreeNode *root,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> createNode(data);</span><br><span class="line">    <span class="keyword">if</span>(data &lt; root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = Insert(root-&gt;left,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = Insert(root-&gt;right,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p><code>前序遍历</code>就是先访问跟节点，然后开始向下访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preorderTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">        preorderTree(root-&gt;left);</span><br><span class="line">        preorderTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><code>中序遍历</code>就是先访问二叉树的左节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorderTree(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">        inorderTree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><code>略略略</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】1.两数之和-C</title>
      <link href="/2023/08/12/2023-8-12-16-30-31-c-leetcode/"/>
      <url>/2023/08/12/2023-8-12-16-30-31-c-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><h2 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p> 按照我们正常思路来说，两次<code>for</code>循环来判断里边的相加数</p><p>在我们自己的ubuntu上进行测试，需要我们将leetcode中的缺少的<code>main</code>函数补充完整，依次来验证我们的正确性。</p><p>leetCode中给我们提供了函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 寻找数组中相加的两数之和等于我们传入的目标数</span></span><br><span class="line"><span class="comment"> * @params nums 传入的数组</span></span><br><span class="line"><span class="comment"> * @params numsSize 传入的数组长度</span></span><br><span class="line"><span class="comment"> * @params target 目标数</span></span><br><span class="line"><span class="comment"> * @params returnSize 最后得到数组的长度</span></span><br><span class="line"><span class="comment"> * return 返回得到的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>;</span><br></pre></td></tr></table></figure><p>要注意返回值是<code>int *</code>，指针类型，也就是我们的最后存储的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>;</span><br><span class="line"><span class="comment">/* 先补充下leetcode中需要的main函数，如果你实在leetcode答题界面，以下不需要写 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//以leetcode给我们的第一个例子来演示</span></span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numsSize = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> returnSize;</span><br><span class="line">    <span class="comment">//以上全部是需要传入函数的参数</span></span><br><span class="line">    <span class="type">int</span> *getTwoNums = <span class="literal">NULL</span>;<span class="comment">//最后得到的数组指针</span></span><br><span class="line">    getTwoNums = twoSum(nums,numsSize,target,&amp;returnSize);</span><br><span class="line">    <span class="comment">//尽管这种情况在leetcode测试代码中不会出现，但是我们最好还是对得到的数组合法性进行一个判断</span></span><br><span class="line">    <span class="keyword">if</span>(getTwoNums == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getTwoNums is null\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//函数结束，下边不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;returnSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getTwoNums[%d] = %d\n&quot;</span>,i,getTwoNums[i]);<span class="comment">//打印查看我们得到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是我们补充的leetcode中缺少的main部分，可用来我们在本地进行一个测试，查看执行的效果。</p><p>接下来编写最主要的函数处理，也就是力扣中要我们添加进去的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line"><span class="comment">//因为返回值是指针，我们需要为存储我们两个变量的数组申请一块内存，以防止此函数结束时编译器不会给我们回收掉</span></span><br><span class="line">    <span class="type">int</span> *returnNums = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//按照我们正常思路，两层for循环来遍历查找里边相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>; a&lt;numsSize<span class="number">-1</span>; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=a+<span class="number">1</span> ;b&lt;numsSize; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[a]+nums[b])==target)</span><br><span class="line">            &#123;</span><br><span class="line">                returnNums[(*returnSize)++] = a;</span><br><span class="line">                returnNums[(*returnSize)++] = b;</span><br><span class="line">                <span class="keyword">return</span> returnNums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就搞定了，<code>returnNums</code>数组中存储了我们得到的两个数的下标。不过它的时间复杂度为O(n^2)，是一种最普通的解法。</p><p>编译我们的程序，<code>gcc 1.TwoAdd.c</code>,得到<code>a.out</code>。最后执行我们的程序<code>./a.out</code>，可以看到打印结果为</p><p><code>[0,1]</code>，正好是我们得到的两个数的数组下标</p><p><img src="/pic/note/note3.jpg"></p><p>讲代码提交到leetcode，可以查看时间消耗与空间占用</p><p><img src="/pic/note/note5.jpg"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>以上方法是最常用的方法：<code>暴力破解</code>，两层for循环嵌套，时间复杂度为<code>O(n^2)</code>，但是目前我们的计算机存储可以完全不考虑空间占用，所以，目前牺牲空间来提高时间效率是现在经常使用的。为此，我们需要降低时间复杂度，降到<code>n^2</code>以下</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种数据结构，它是通过<code>键值对</code>的映射来存储数据，只要映射方式能够满足我们的需求就可以，哈希表的查找时间复杂度一般情况速度挺快的。</p><p>使用c语言中扩展库<code>uthash.h</code>来实现简单的哈希表</p><p>关于uthash.h库，可以到仓库查看。(<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a>)</p><p>我已经提前讲源代码放入到linux的lib库中了，接下来使用它。</p><p><code>uthash.h</code>中提供了基础的哈希表。所以我们只需要自己准备好要映射的结构</p><p>对于<code>两数之和</code>来说，所有数据都是整型数，所以，键值对就设定为整型数就行</p><p><strong>UT_hash_handle</strong>是uthash库中提供的，可以链接到哈希表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span>  <span class="comment">//创建自己的键值对</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;  <span class="comment">//uthash的特殊字段，用于讲该结构链接到哈希表中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建一个指针，用于表示哈希表本身"><a href="#创建一个指针，用于表示哈希表本身" class="headerlink" title="创建一个指针，用于表示哈希表本身"></a>创建一个指针，用于表示哈希表本身</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">hashtable</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hashTable* <span class="title function_">find_val</span><span class="params">(<span class="type">int</span> ikey)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HASH_FIND_INT</strong>是uthash中提供的查找整数的宏,与此相似的还有<strong>HASH_FIND_PTR</strong>、<strong>HASH_FIND_STR</strong>等等。</p><p><code>find_val</code>用于查找哈希表中存在的键值对ikey的元素，如果找到了返回该元素的指针，找不到就返回NULL；</p><h3 id="哈希表的插入"><a href="#哈希表的插入" class="headerlink" title="哈希表的插入"></a>哈希表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ikey, <span class="type">int</span> ival)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find_val(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code>函数用于向哈希表中插入元素或者更新已有的元素，首先，通过<code>find_val</code>来查找表中是否有ikey的元素，如果没有就<code>malloc</code>创建一个元素，然后通过<code>HASH_ADD_INT</code>将该元素的键值对存储到哈希表中，如果有ikey的元素，就更新元素的值val。</p><h2 id="哈希表的两数之和解法"><a href="#哈希表的两数之和解法" class="headerlink" title="哈希表的两数之和解法"></a>哈希表的两数之和解法</h2><p>以上是简单介绍uthash库的哈希中使用到的，接下来处理解决leetcode第一题：两数之和。</p><p>我们的思路是：<strong>遍历数组，同时判断target-nums[i]的值存不存在于我们的哈希表中，如果不存在，将该nums[i]和i当作一个哈希元素存储到我们的哈希表中，这样，在我们继续向下遍历的时候，继续判断哈希表中有无(target-nums[i])这个元素，如果有就直接取对应的i</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span>  <span class="comment">//创建自己的键值对</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;  <span class="comment">//uthash的特殊字段，用于讲该结构链接到哈希表中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">hashtable</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hashTable* <span class="title function_">find_val</span><span class="params">(<span class="type">int</span> ikey)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ikey, <span class="type">int</span> ival)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find_val(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解题</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">numsAdd</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span> *returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//1.先将哈希表清空</span></span><br><span class="line">   hashtable = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//创建哈希元素来查找哈希表中是否存在(target-nums[i])的元素。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">it</span> =</span> find_val(target-nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在的情况</span></span><br><span class="line">            <span class="type">int</span> *ret = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val;</span><br><span class="line">            ret[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在，将该nums[i]和i插入到我们的哈希表中</span></span><br><span class="line">        insert(nums[i],i);<span class="comment">//注意，对应上我们的结构体,第一个参数是key,第一个参数是value,我们在上边要取得是value的元素。</span></span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历到最后也没找到合适的两数之和的元素。</span></span><br><span class="line">   *returnSize = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历一边数组的方式将原本的<code>O(n^2)</code>的时间复杂度压缩到了<code>O(n)</code>。</p><p>把代码提交到leetcode看下结果</p><p><img src="/pic/note/note6.jpg"></p><p>速度快多了相比之前的76ms。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>守住你的瓦尔登湖</title>
      <link href="/2023/08/11/2023-8-11-23-59-46-Forth/"/>
      <url>/2023/08/11/2023-8-11-23-59-46-Forth/</url>
      
        <content type="html"><![CDATA[<h1 id="守住你的瓦尔登湖"><a href="#守住你的瓦尔登湖" class="headerlink" title="守住你的瓦尔登湖"></a>守住你的瓦尔登湖</h1><p><code>杨 虎</code><br>1949年,梭罗和他的湖首次来到了中国。译者徐迟在序言中这样说道:“你能把你的心安静下来吗?如果你的心并没有安静下来,我说,你也许最好是先把你的心安静下来,然后你再打开这本书,否则你也许会读不下去,认为它太浓缩,难读,艰深,甚至会觉得它莫名其妙,不知所云。”那时正值天翻地覆,安静的梭罗不知能走进多少人的内心?<br>中国内地的读者再次看到大洋彼岸这个“怪人”的身影已是33年后的1982年了。但这一次,席卷古老大陆的文学热潮即将汹涌起马尔克斯的魔方、乔伊斯的呓语,而狂热的读者们则兴奋地从小说中检索着改革、承包等字眼,为物质时代正义凛然地登场暗暗兴奋不已。<br>又一次,梭罗和他的瓦尔登湖被时代的喧嚣所淹没。<br>其实,这本书本来就是为人类中那些安静的内心写的,小众化正该是它的命运。这本诞生在湖边的书,或许是大自然最美的精灵之一,湖泊为寻找芸芸众生中和她质地一样的心湖而假手梭罗发出的信号。<br>共鸣,从来只发生在知己之间。<br>水是大地的灵者,是人生的天籁表达。如果河流象征着人生奔突冲撞的青年时代,海洋则像是童年和老年的重叠,而湖泊这大地上晶亮的眼睛,则是人生静穆平和信念坚定的中年。我不知道梭罗是怎么下决心要为人类写这一本宁静的中年之书的。或许,是瓦尔登湖翻卷的浪花突然击中了他的灵魂;或许,这一需求潜伏已久,也许更早以前,他在某个喧闹的时刻突然听到了自己内心的低语,就像叶芝在伦敦的街头忽然热泪盈眶:“我就要动身走了,去茵纳斯弗利岛;我就要动身走了,因为我听到,那水声日日夜夜轻拍着湖滨;不管我站在车行道,还是人行道,我都在心灵深处听见这声音。”<br>这样的向往,也许也曾多次在你我的内心翻涌,只是,我们不愿像梭罗那样去正视一个真实的自己,不敢像他那样舍弃世俗的一切去寻找和守住自己的瓦尔登湖。<br>人类中那些柔软与敏感的心灵总是代替凡夫俗子去感受天籁,并九死不悔地承担由此落在自己命运中的狂喜与极苦。梵高如是,高更如是,梭罗也如是。但这一次,是人类与大自然最美丽的邂逅——1844年一个落叶纷飞的秋日,27岁的亨利·戴维·梭罗只影单身,仅带着一柄斧头和二十五美元二十一美分,住进了杳无人迹的瓦尔登湖边的山林中。在此之前,他已给爱默生当了两年助手。再往前,他亲眼目睹了恋人的他嫁和相依为命的哥哥的死亡。再往前,1837年,他毕业于著名的哈佛大学。<br>大自然是灵魂永恒的港湾。犹如母亲和情人,瓦尔登湖澄净的色彩让梭罗翻涌的内心一下子抵达了安静并狂热起来。安静的是他的情绪,狂热的是他的思绪,是他长久以来寻找的对话与表达。从1844年秋到1847年,短短一千多个日夜,瓦尔登湖拍岸的水声从梭罗心上流过,再一次流出就成了芬芳的墨香。<br>但这本书绝不是隐逸者说。事实上,它隐含的最重要的主题之一就是对自我的尊重与发现,对生命的真实与神圣的寻求。从这个意义上说,我们每一个人的内心都可能是一块小小的瓦尔登湖。只是,碌碌红尘里的你我总是在对碌碌红尘的房子、职务与收入等的追赶与算计中忽略了自己的内心。静静跟着梭罗的脚印走下去,你蛰居的生命就会豁然舒伸,你内心的瓦尔登湖就会为你打开美丽的四季。<br>发现并守住你的瓦尔登湖吧,我们每个人都可能是自己的梭罗。要知道,人间每走一个人,天上就会落一颗星。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式c语言-基本数据类型和结构</title>
      <link href="/2023/08/09/2023-8-9-20-05-54-Third/"/>
      <url>/2023/08/09/2023-8-9-20-05-54-Third/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式c语言【第一讲】-基本数据类型"><a href="#嵌入式c语言【第一讲】-基本数据类型" class="headerlink" title="嵌入式c语言【第一讲】-基本数据类型"></a>嵌入式c语言【第一讲】-基本数据类型</h1><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>嵌入式里常用c语言，如果是linux开发，也会常用c++和其他的一些语言，不过为了基础一点，从c语言开始记录。</p><p>嵌入式c语言开篇，常用作通过编程来控制硬件，当前编程语言很多，与硬件打交道的基本都是c语言，51，stm32的一些硬件，可以编写程序烧录到芯片内部的flash(存储区)来让硬件自己执行程序，达到你想要的效果。</p><p>当然当前编程语言太多了，不过我还是打算从c基础开篇开始记录下。</p><h2 id="前提环境"><a href="#前提环境" class="headerlink" title="前提环境"></a>前提环境</h2><p>我的建议是有虚拟机vmware或者是在linux系统下编程，如果不知道linux，可以从网上找vmware软件来下载，然后从ubuntu官网下载一个系统镜像安装到vmware中，具体操作步骤可以自行从网上搜索。当然如果你有云服务器也可以，只要是linux操作系统就行，因为涉及到编译等环境搭建很简单。</p><h2 id="c语言基本类型"><a href="#c语言基本类型" class="headerlink" title="c语言基本类型"></a>c语言基本类型</h2><p>在基本类型之前我要说明几点：</p><p><code>关键字</code>，编程语言都有所谓的关键字，关键字就是告诉机器你句话是什么意思，他好按照你给他的关键字来将你写好的程序编译成机器语言好去执行，机器语言就是只有机器能读懂的语言，也就是二进制格式，0和1，机器底层只能执行0和1，所以要按照你给的关键字将代码最终整理成0和1。</p><p>c语言的关键字有：</p><p>​<code>auto</code> ：声明自动变量</p><p>​ <code>break</code>：跳出当前循环</p><p>​ <code>case</code>：开关语句分支</p><p>​ <code>char</code>：声明字符型变量或函数返回值类型</p><p>​ <code>const</code> ：声明只读变量</p><p>​<code>continue</code>：结束当前循环，开始下一轮循环</p><p>​<code>default</code>：开关语句中的“默认”分支</p><p>​<code>do</code> ：循环语句的循环体</p><p>​ <code>double</code> ：声明双精度浮点型变量或函数返回值类型</p><p>​ <code>else</code> ：条件语句否定分支（与 if 连用）</p><p>​ <code>enum</code> ：声明枚举类型</p><p>​ <code>extern</code>：声明变量或函数是在其它文件或本文件的其他位置定义</p><p>​<code>float</code>：声明浮点型变量或函数返回值类型</p><p>​ <code>for</code>：一种循环语句</p><p>​<code>goto</code>：无条件跳转语句</p><p>​<code>if</code>：条件语句</p><p>​ <code>int</code>： 声明整型变量或函数</p><p>​ <code>long</code> ：声明长整型变量或函数返回值类型</p><p>​ <code>register</code>：声明寄存器变量</p><p>​ <code>return</code> ：子程序返回语句（可以带参数，也可不带参数）</p><p>​ <code>short</code> ：声明短整型变量或函数</p><p>​ <code>signed</code>：声明有符号类型变量或函数</p><p>​ <code>sizeof</code>：计算数据类型或变量长度（即所占字节数）</p><p>​<code>static</code> ：声明静态变量</p><p>​ <code>struct</code>：声明结构体类型</p><p>​ <code>switch</code> :用于开关语句</p><p>​ <code>typedef</code>：用以给数据类型取别名</p><p>​ <code>unsigned</code>：声明无符号类型变量或函数</p><p>​ <code>union</code>：声明共用体类型</p><p>​<code>void</code> ：声明函数无返回值或无参数，声明无类型指针</p><p>​ <code>volatile</code>：说明变量在程序执行中可被隐含地改变</p><p>​ <code>while</code> ：循环语句的循环条件</p><p>乍一看很多，其实常用的也就几个，循环语句使用while，for</p><p>判断使用：if，或者三目运算符，<strong>三目运算符</strong>到后边再讲。</p><p>还有条件多的情况下使用：switch case，比if速度要快。</p><p>还有基本的类型声明</p><pre><code>     1.整型：`int`</code></pre><p>​ 2.字符型：<code>char</code></p><p>​ 3.短整型：<code>short</code></p><p>​ 4.长整型：<code>long</code></p><p>​ 5.长长整型：<code>long long</code></p><p>​ 6.浮点型：<code>float</code></p><p>​ 7.双精度浮点型：<code>double</code></p><p>以上声明的数据类型都是有符号的，无符号的在前边声明<code>unsigned</code>。</p><p>例子：</p><p>​ 声明一个整型变量a：<strong>int a</strong>;</p><p>​ 一个字符类型变量b：<strong>char b</strong>;</p><p>​ 一个短整型变量c：<strong>short c</strong>;</p><p>等等，无符号类型就是在前边加上<code>unsigned</code>来修饰</p><p>​ 一个无符号整型变量a：<strong>unsigned int a</strong>;</p><p>​ 一个无符号字符类型变量b：<strong>unsigned char b</strong>;</p><p>​ 一个无符号短整型变量c：<strong>unsigned short c</strong>;</p><h2 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h2><p>有符号的意思是这个变量的空间的最高位，代表着该数是<strong>正数</strong>还是<strong>负数</strong></p><p>一个<code>int</code>类型的变量，它在程序空间里边占着四个字节的单位。</p><p>我们的机器，最底层内部结构其实是分布很多的0与1的小空间。这个小空间只有高与低，就像一个只能装一滴水的杯子，要么是空杯子<strong>0</strong>，要么就是装水的杯子(一滴水)<strong>1</strong>。这些空间(杯子)八个连在一起。</p><p><img src="/pic/note/note.jpg"></p><p><code>无符号</code>的意思就是这八个位组成的一个字节，他的大小范围就是从0<del>(2^8-1)的大小，也就是0</del>255，一共能表示256个数。它不能表示负数，毕竟没有符号。</p><p>当有符号的话，最高位就也就是如下图</p><p><img src="/pic/note/note2.jpg"></p><p>箭头所表示的最高位，它就与其他位区别开来，如果最高位为<strong>0</strong>，表示是个正数，如果这一位为<strong>1</strong>，表示整体就是一个负数，具体范围就是<code>-128</code><del><code>127</code>，不过这一个字节能表示的范围也是256个数，只不过相当于从<strong>0</strong></del><strong>255</strong>分割开了，取了其中的一半来当作负数。</p><p>在编程语言中，<strong>一个字节有8个bit位，bit位表示0或者1，这8个bit位组成一个字节，也就是我们常常定义一个char类型变量的时候的空间大小.</strong></p><p><code>char</code> <strong>一个字节</strong></p><p>范围：**-128~127**</p><p>无符号范围：<strong>0~255</strong></p><p><code>short</code><strong>两个字节</strong></p><p> <strong>-32768~32767</strong></p><p><strong>0~65535</strong></p><p><code>int</code><strong>四个字节</strong></p><p><strong>-2^15~2^15-1</strong></p><p><strong>0~2^32-1</strong></p><p><code>long</code> <strong>八个字节</strong></p><p>这是我们目前常用的。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值语句就是<code>=</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1000</span>;<span class="comment">//赋值a给1000</span></span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环命令"><a href="#循环命令" class="headerlink" title="循环命令"></a>循环命令</h3><p>循环语句使用<code>for</code>与<code>while</code></p><p><code>for(初始条件;临界条件;执行语句后的命令) &#123;循环执行的命令&#125;</code></p><p><code>while(判断条件)&#123;循环执行的命令&#125;</code></p><p>简单例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(a = <span class="number">0</span>; a&lt;<span class="number">10</span>; a++)<span class="comment">//循环10次执行中括号内的命令</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">20</span>)<span class="comment">//循环20次执行中括号内的命令，变量a要记得每次+1,不然造成死循环,只能靠break来跳出</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">a++;<span class="comment">//a = a + 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><p><code>break</code>是跳出循环，如果有循环嵌套的请款，只能跳出一层循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">while</span>(b&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ···</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//只能跳出当前while(b&lt;10)的循环，跳出之后回到while(a&lt;10)内执行的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>if</code>语句用来条件判断，通常使用的还有<strong>三目运算符</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)</span><br><span class="line">&#123;<span class="comment">/* if条件成立*/</span></span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/* if条件不成立执行下边的语句 */</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>多个if-else判断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(d&lt;a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;a\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d&lt;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d&lt;c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d最大&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上命令执行后最后进入的分支是第三个<code>if(d&lt;c)</code>的执行命令，打印输出”d&lt;c”</p><p><strong>注意</strong>：当你的<code>if-else</code>如果特别多的话，执行效率会很低，因为<strong>每次一个if条件不成立，他都会判断下一个if条件，知道最后进入if成立的语句才执行其内部的命令</strong>，像上边的<strong>四个if判断</strong>(在这里最后的else也可以看作是一个if判断)。<strong>“if语句内部的条件判断,是布尔类型，也就是<code>真``假</code>两种判断结果，如果if里边写成这样  if(a&#x3D;1) 编译器是会认为里边的条件为真，因为它里边并不是什么判断语句，而是赋值语句，这点要注意 ”</strong></p><p>在很多时候我们确实要用很多判断，如果条件可以我推荐使用<code>switch case</code>语句，或者把<code>switch case </code>与 <code>if -else</code>结合使用，也许能提高你程序的运行速度。</p><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>它的执行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = 0\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 1\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 2\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span><span class="number">&#x27;</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 10\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a为其他\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上执行的结果是<strong>a &#x3D; 10</strong>，相比使用<code>if-else</code>来说速度很快，如果是<code>if-else</code>的话，这个应该这样写了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 0\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 10\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a为其他\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if判断到第11条也就是<code>else if (a == 10)</code>才能真正执行打印 <strong>a &#x3D; 10</strong>的语句，相比<code>switch-case</code>来说效率太低。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符分为<code>符号运算符</code>和<code>逻辑运算符</code></p><h3 id="符号运算符"><a href="#符号运算符" class="headerlink" title="符号运算符"></a>符号运算符</h3><p>常见的<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>这四个，加减乘除，<strong>注意，除法得到的只能是整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">3</span>,c;</span><br><span class="line">c = a / b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>最后打印结果为<code>c = 3</code></p><p><code>%</code>为取余，比如<code>10%3</code>，这个结果就是1，<code>15%6</code>，结果就是3，或者是<code>20%4</code>，结果就是0</p><p>除此之外，还有一些<code>位与运算</code>，</p><p>​与运算：<code>&amp;</code></p><p>​或运算：<code>|</code></p><p>​非运算：<code>~</code></p><p>​异或运算:<code>^</code></p><p>如果两个数进行与以上四种运算，那这两个数一定不会很复杂。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日月山</title>
      <link href="/2023/02/23/2023-2-26-14-11-03-First/"/>
      <url>/2023/02/23/2023-2-26-14-11-03-First/</url>
      
        <content type="html"><![CDATA[<h1 id="日月山"><a href="#日月山" class="headerlink" title="日月山"></a>日月山</h1><p>​长住西宁的朋友开车送我出来，一路往高处走。“有反应吗？”朋友问。“心跳有点快。”“乍来都这样。到日月山你反应会更明显。”朋友开车，把一首叫《鸿雁》的歌声音开得很大。<br>我有点心慌，但不是因为缺氧。我想此刻我妹妹一定有点心动过速，我感到了她的那种心慌。我们是孪生兄妹。她在北京，正准备嫁人结婚。她让我来日月山看一个人。我该对那个叫扎西的藏族小伙子说点啥呢？<br>        “你想说什么就说什么。”我妹妹说，“你要什么都不想说，就说，你是我哥。他会明白。”<br>我见过那个叫扎西的藏族小伙子的照片。他和我妹妹站在西宁街头，坐在青海湖边，站在布达拉宫脚下，坐在大昭寺前，每个人跷起一只脚独立于八角街边的大风里。在这些照片上，我妹妹吊在扎西的脖子上，张大嘴开心地笑，露出了好看的牙齿。帅帅的扎西头发长长的，笑得比较节制，像个康巴汉子。<br>​       他俩是在西宁那条著名的美食街遇上的，扎西买了一串硕大的烤羊肠递给她，我妹妹只吃了其中的一小截。第二天他们又在日月山碰到了。扎西是日月山最年轻的牦牛客，他牵的白牦牛两只角优雅地弯曲着，脑门上顶着一朵大红绸子扎成的花。扎西对我妹妹说：“上来吧，一分钱不要，想去哪儿都行。”扎西笑了，牙很白，像日月山顶峰上的雪。<br>​       后来，我妹妹想留在日月山下扎西家的小平房里。我爸妈说：肯定不行！旅游结个伴儿还可以，要结婚一块过日子，没戏。事实也如此，我妹妹不可能一辈子生活在缺氧的拉萨、西宁和日月山，她的心肺功能先天不好，还吃不了羊肉。我爸妈硬把她从青海的日月山下拽了回来。妹妹回来了，拉杆箱里的一部分行李还舍不得全拿出来。我妈把妹妹的心电图报告单抖得哗哗响，指着窗外的中关村大街：“还想走？走了你就不用再回来了！”<br>​       阳光不见了。天低下来，落下了雪。“怎么回事？这可是五月了！”我说。“谁说雪就得在正月里下？”朋友回答我，“你要待在这里，会发现六月照样下雪。”果真，雪越下越大，天地间一片苍茫。初夏走了，冬天跟着一场大雪杀了一个回马枪。车在世界屋脊上继续跑，高速公路像腰带一样打起了弯。“喏，”朋友说，“那就是日月山。”<br>​我把日月山想高了。我知道她是圣山、神山。我以为日月山一定壁立千仞险峻高拔，应该是奇峰迭起般的十万大山，事实上她就是比高原更高的隆起、隆起、再隆起，她的隆起和攀升安静、从容、柔和，有一种风起云涌但又漫不经心的力量。<br>​买了进景区的票，朋友让我把所有的衣服都穿上，风帽戴好，他就待在车里了。日月山他来几十回了。“看，那是日亭，那是月亭。当年文成公主赴吐蕃和亲，走到日月山，思乡心切，回望长安，把皇后送给她的日月宝镜拿出来照，竟在镜子里看见了京城长安的繁华盛景，且惊且喜且悲，情不自胜，宝镜脱手，摔成了两半。一半为日，一半为月，日月山就是这么来的。你看，那雕像就是文成公主，那块石头就是回望石。回头望长安，可怜无数山。”<br>​不知道文成公主嫁给松赞干布以后，是否习惯粗粝动荡的游牧生活。她喝得惯吐蕃的酒么？吃得惯带膻味的牛羊肉么？从长安到这里，千万里也，车辚辚，马萧萧，文成公主硬是走过来了。我用围巾围住鼻子和嘴，只剩一双眼睛看世界。好像整个日月山只有我一个游客。此外就是一个磕长头的藏族老人，走几步扑通跪倒，舒展开身体匍匐在雪地上，起身，走几步，再跪倒，匍匐。他的脸是一块静默的黑石头。<br>​我先沿着台阶往日亭上走，上两个台阶我就停一下，调整好呼吸的节奏再走。这个节奏是妹妹告诉我的，她说是扎西总结的经验，要不她那样的内地女孩，在青藏高原上早歇菜了。扎西的节奏很管用，但我在日亭边上没有找到扎西。早上我给扎西家里打过电话，他妈妈说扎西一大早就牵着牦牛带着干粮上山了。从那边下来，我又往月亭爬，一路留心山道上的活物。站在月亭边上，我才看见另一边的山道上站着一头牦牛。雪还在下，要不是牛头上的红绸子和牛背上色彩鲜艳的坐垫，那头白牦牛就被大雪遮蔽了。我又费力地在牦牛周围看了半天，才看见地上坐着一个人。他是最后的希望。日月山上此时不会再有第二个牦牛客了。在我走到他面前的十几分钟里，牦牛摇了两下头，甩了三次尾巴，他像文成公主雕像一样动都没动。<br>​我说：“兄弟，走两圈？”<br>​他抬起头，光头，没戴帽子，但我知道他就是扎西。他比我妹妹的照片里黑了一点，也老了一些，脸上出现了干燥的皱纹。<br>​“怎么走？”他问。<br>​“随便。走你最喜欢走的那条线。”<br>​我骑在牦牛上，他在左前方牵着缰绳。可能是出于习惯，因为一大早出门时天很好，他的衣服在风雪里看上去有点单。他的腰间缀着个阴刻雕花铜环，铜环下肯定没有流苏，这是我妹妹的风格。<br>​一头牛，两个人，我们孤零零地走在日月山的风雪里。好半晌，还是我用问话打破了沉默。<br>​“你是本地人？”“嗯。睁开眼睛看见的就是日月山。”“没想过去西宁？”“过去想过。”<br>​“现在呢？”“不想了。”“为什么？”“日月山好。”“那，北京呢？”<br>​他停下来，扭了半个头看我，好像我说的是外语。“北京？”他用方言说了这个词，笑了一声，“太远了。”<br>​沉默。<br>​“日月山好在哪儿？”我还是问出了这个问题。<br>​他停下来，想了想，说：“地老天荒。”<br>​终点到了。我不能再在牛背上待下去了。跳下牛背的时候我拉下围巾，露出完整的一张脸。按照扎西式节奏调整了呼吸之后，我才说：<br>​“你看我长得像谁？”“你自己啊。”<br>​“我的意思，你知道我是谁么？”<br>​他笑了笑，“一个游客。”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>说明</title>
      <link href="/2023/02/23/2023-3-21-22-42-33-Second/"/>
      <url>/2023/02/23/2023-3-21-22-42-33-Second/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h2><pre><code>从今天开始就不定期的更新博客了，说是博客，日志</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
