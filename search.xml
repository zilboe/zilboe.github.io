<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Rust】第四十四章：实例：重构将业务逻辑移动到lib.rs</title>
      <link href="/2024/02/28/2024-2-28-21-12-00-rust-44/"/>
      <url>/2024/02/28/2024-2-28-21-12-00-rust-44/</url>
      
        <content type="html"><![CDATA[<h1 id="重构：将业务逻辑移到lib-rs中"><a href="#重构：将业务逻辑移到lib-rs中" class="headerlink" title="重构：将业务逻辑移到lib.rs中"></a>重构：将业务逻辑移到lib.rs中</h1><p>看上一张代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"><span class="comment">//添加文件库</span></span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::process;    <span class="comment">//上一章遗留问题</span></span><br><span class="line"><span class="keyword">use</span> std::error::Error;    <span class="comment">//本章添加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本章添加</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本章添加run</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>， contents);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    query: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写解析函数</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;                   </span><br><span class="line">      <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[string]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;query, filename&#125;)</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下可以看作是config的构造函数,与Config相关联的构造函数</span></span><br><span class="line"><span class="comment">//fn parse_config(args: &amp;[string]) -&gt; Config &#123;</span></span><br><span class="line"><span class="comment">//    let query = args[1].clone();</span></span><br><span class="line"><span class="comment">//    let filename = args[2].clone();</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Config &#123;query, filename&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>以上是单独的一个main.rs文件，接下来我们把业务逻辑相关的代码全部导入lib.rs中</p><p>main.rs中的内容为以下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Application error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>lib.rs文件内容</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt;<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;query, filename&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第四十三章：重构错误处理</title>
      <link href="/2024/02/27/2024-2-27-20-38-00-rust-43/"/>
      <url>/2024/02/27/2024-2-27-20-38-00-rust-43/</url>
      
        <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>继续上一张代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"><span class="comment">//添加文件库</span></span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">//本章修改8-12</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//用来读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>， contents);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    query: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写解析函数</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;                    <span class="comment">//本章27</span></span><br><span class="line">      <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[string]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">//本章：添加对参数的错误处理</span></span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;query, filename&#125;)</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以下可以看作是config的构造函数,与Config相关联的构造函数</span></span><br><span class="line"><span class="comment">//fn parse_config(args: &amp;[string]) -&gt; Config &#123;</span></span><br><span class="line"><span class="comment">//    let query = args[1].clone();</span></span><br><span class="line"><span class="comment">//    let filename = args[2].clone();</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Config &#123;query, filename&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第四十二章：重构模块化</title>
      <link href="/2024/02/26/2024-2-26-21-30-00-rust-42/"/>
      <url>/2024/02/26/2024-2-26-21-30-00-rust-42/</url>
      
        <content type="html"><![CDATA[<h1 id="重构模块化"><a href="#重构模块化" class="headerlink" title="重构模块化"></a>重构模块化</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"><span class="comment">//添加文件库</span></span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以将获取到的值进行打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;search for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>， contents);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一章最后我们的代码</p><ul><li>它里边有很多个功能，所以我们将每个功能分成模块来实现</li><li>函数中定义了很多的变量，有的变量是属于同一组的，比如query和filename，而contents是负责业务的，所以变量需要定义成一个结构体</li><li>错误处理，当前我们只使用了一个expect错误，当读取失败的时候只会打印这一条信息，但是实际上错误有很多种，比如没有权限，文件不存在等</li></ul><h2 id="二进制程序关注点分离的指导性原则"><a href="#二进制程序关注点分离的指导性原则" class="headerlink" title="二进制程序关注点分离的指导性原则"></a>二进制程序关注点分离的指导性原则</h2><ul><li>将程序拆分为main.rs和lib.rs，将业务逻辑放入lib.rs</li><li>当命令行解析逻辑较少时，将它放在main.rs也行</li><li>当命令行解析逻辑变复杂时，需要将它从main.rs提取到lib.rs</li></ul><h2 id="经过上述拆分，留在main的功能有："><a href="#经过上述拆分，留在main的功能有：" class="headerlink" title="经过上述拆分，留在main的功能有："></a>经过上述拆分，留在main的功能有：</h2><ul><li>使用参数值调用命令行解析逻辑</li><li>进行其他配置</li><li>调用lib.rs中的run函数</li><li>处理run函数可能出现的错误<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"><span class="comment">//添加文件库</span></span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line">    <span class="comment">//用来读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>， contents);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    query: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写解析函数</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">      <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[string]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    </span><br><span class="line">        Config &#123;query, filename&#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下可以看作是config的构造函数,与Config相关联的构造函数</span></span><br><span class="line"><span class="comment">//fn parse_config(args: &amp;[string]) -&gt; Config &#123;</span></span><br><span class="line"><span class="comment">//    let query = args[1].clone();</span></span><br><span class="line"><span class="comment">//    let filename = args[2].clone();</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Config &#123;query, filename&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>下一章进行错误处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第四十一章：读取文件</title>
      <link href="/2024/02/25/2024-2-25-19-00-00-rust-41/"/>
      <url>/2024/02/25/2024-2-25-19-00-00-rust-41/</url>
      
        <content type="html"><![CDATA[<h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><p>接上一章内容</p><p>在项目下添加一个txt文件，内容是合法的unicode字符</p><p>打开main.rs文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"><span class="comment">//添加文件库</span></span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以将获取到的值进行打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;search for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Something went wrong reading the file&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;With text:\n&#123;&#125;&quot;</span>， contents);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上虽然实现了这个打开文件的功能，但是逻辑上这个代码不方便后期维护或者修改，还有一种问题就是没有处理一些瑕疵问题。</p><p>下一章进行代码重构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第四十章：实例：接收命令行参数</title>
      <link href="/2024/02/24/2024-2-24-19-48-00-rust-40/"/>
      <url>/2024/02/24/2024-2-24-19-48-00-rust-40/</url>
      
        <content type="html"><![CDATA[<h1 id="项目实例：制作一个简单的grep工具，在一个文件里搜索指定的字符串"><a href="#项目实例：制作一个简单的grep工具，在一个文件里搜索指定的字符串" class="headerlink" title="项目实例：制作一个简单的grep工具，在一个文件里搜索指定的字符串"></a>项目实例：制作一个简单的grep工具，在一个文件里搜索指定的字符串</h1><p>在终端创建一个新的工程文件：<code>cargo new minigrep</code></p><p>我们最终运行格式是这种：<code>cargo run xxxx xxxx.txt</code></p><h1 id="接收命令行参数"><a href="#接收命令行参数" class="headerlink" title="接收命令行参数"></a>接收命令行参数</h1><p>进入main.rs文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以将获取到的值进行打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以执行：<code>cargo run</code> ，能看到打印了我们工程的二进制文件名,也就是第一个参数。</p><p>我们添加参数执行：<code>cargo run 1234 abcd</code>，同样能看见打印了1234 abcd两个参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用环境变量的库</span></span><br><span class="line"><span class="keyword">use</span> std::env::<span class="title function_ invoke__">args</span>();    <span class="comment">//args会返回一个迭代器,它会返回一系列的值,我们需要collect</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> :<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以将获取到的值进行打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;search for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十八章：测试组织：单元测试</title>
      <link href="/2024/02/23/2024-2-23-22-59-00-rust-38/"/>
      <url>/2024/02/23/2024-2-23-22-59-00-rust-38/</url>
      
        <content type="html"><![CDATA[<h1 id="测试组织：单元测试"><a href="#测试组织：单元测试" class="headerlink" title="测试组织：单元测试"></a>测试组织：单元测试</h1><p>Rust对测试的分类：</p><ul><li>单元测试</li><li>集成测试<br>单元测试：</li><li>小、专注</li><li>一次对一个模块进行隔离的测试</li><li>可测试private接口<br>集成测试：</li><li>在库外部。和其他外部代码一样使用你的代码</li><li>只能使用public接口</li><li>可能在每个测试中使用到多个模块</li></ul><h2 id="cfg-test-标注"><a href="#cfg-test-标注" class="headerlink" title="#[cfg(test)]标注"></a>#[cfg(test)]标注</h2><p>test模块上的#[cfg(test)]标注：</p><ul><li>只有运行cargo test才编译和运行代码</li><li>运行cargo build则不会<br>集成测试在不同的目录，它不需要[#cfg(test)]标注<br>cfg:configuratuib（配置）</li><li>告诉rust下面的条目只有在指定的配置选项下才被包含</li><li>配置选项test：由rust提供，用来编译和运行测试。<ul><li>只有cargo test才会编译代码，包括模块中的helper函数和#[test]标注的函数<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h2><p>Rust允许测试私有函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">internal_adder</span>(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行cargo test正常运行通过</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十八章：测试组织：单元测试</title>
      <link href="/2024/02/23/2024-2-23-23-02-00-rust-39/"/>
      <url>/2024/02/23/2024-2-23-23-02-00-rust-39/</url>
      
        <content type="html"><![CDATA[<h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>在rust里，集成测试完全位于被测试库的外边</p><p>目的：是测试被测试库的多个部分是否能正确的一起工作</p><p>集成测试的覆盖率很重要</p><h2 id="tests目录"><a href="#tests目录" class="headerlink" title="tests目录"></a>tests目录</h2><p>创建集成测试：<code>tests目录</code></p><p>tests目录下的每个测试文件都是单独的一个crate</p><ul><li>需要将被测试库导入</li></ul><p>无需标注#[cfg(test)]，tests目录被特殊对待</p><ul><li>只有cargo test，才会编译tests目录下的文件</li></ul><p>创建一个tests目录，新建一个integration_tests.rs文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> adder;    <span class="comment">//项目名称</span></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行指定的集成测试"><a href="#运行指定的集成测试" class="headerlink" title="运行指定的集成测试"></a>运行指定的集成测试</h2><p>运行一个特定的集成测试：<code>cargo test 函数名</code></p><p>运行某个测试文件内的所有测试：<code>cargo test --test 文件名</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;    <span class="comment">//项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_really_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h2><p>tests目录下每个文件被编译成单独的crate</p><ul><li>这些文件不共享行为（与src下的文件规则不同）<br>比如在tests目录下创建一个新的common.rs文件，并非测试文件，而是类似一种帮助文件<br>我们可以在tests目录下新建一个common文件夹，将common.rs放入common文件夹。<br>我们在测试文件integration_tests.rs文件内直接导入这个common.rs模块（帮助模块）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_readlly_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>(); <span class="comment">//setup函数是common.rs的一个空的函数,用来演示</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行cargo test可进行测试</p><h2 id="针对binary-crate的集成测试"><a href="#针对binary-crate的集成测试" class="headerlink" title="针对binary crate的集成测试"></a>针对binary crate的集成测试</h2><p>如果项目是binary crate，只含有src&#x2F;main.rs没有src&#x2F;lib.rs：</p><ul><li>不能在tests目录下创建集成测试</li><li>无法把main.rs的函数导入作用域</li></ul><p>只有library crate才能暴露函数给其他crate用binary crate意味着独立运行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十六章：控制测试运行：按名称运行测试</title>
      <link href="/2024/02/22/2024-2-22-20-48-00-rust-36/"/>
      <url>/2024/02/22/2024-2-22-20-48-00-rust-36/</url>
      
        <content type="html"><![CDATA[<h1 id="按名称运行测试"><a href="#按名称运行测试" class="headerlink" title="按名称运行测试"></a>按名称运行测试</h1><p>按名称运行测试的子集</p><ul><li>选择运行的测试：将测试的名称（一个或多个）作为cargo test的测试<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_two_and_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_three_and_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">3</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_hundred</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">102</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">100</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行测试<code>cargo test</code>测试通过</p><p>如果想要运行一个测试执行：<code>cargo test one_hundred</code><br>如果传递两个参数是不能执行的</p><p>运行单个测试：指定测试名</p><p>运行多个测试：指定测试名的一部分（模块名也可以）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_two_and_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_three_and_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">3</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_hundred</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">102</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">100</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>cargo test add</code>可测试两个模块add_two_and_two，add_three_and_two.<br>因为执行的参数里包含add，所以会测试所有模块中包含add的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十七章：控制测试运行：忽略测试</title>
      <link href="/2024/02/22/2024-2-22-20-48-00-rust-37/"/>
      <url>/2024/02/22/2024-2-22-20-48-00-rust-37/</url>
      
        <content type="html"><![CDATA[<h1 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h1><p>忽略某些测试，运行剩余测试</p><p><strong>ignore</strong>属性（attribute）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="number">2</span>+<span class="number">2</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[ignore]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>cargo test</code>可忽略标记<strong>ignore</strong>的测试</p><p>运行<code>cargo test -- --ignored</code>可单独运行标记ignore的测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十五章：控制测试运行：并行和连续执行测试</title>
      <link href="/2024/02/21/2024-2-21-21-22-00-rust-35/"/>
      <url>/2024/02/21/2024-2-21-21-22-00-rust-35/</url>
      
        <content type="html"><![CDATA[<h1 id="控制测试运行：并行和连续执行测试"><a href="#控制测试运行：并行和连续执行测试" class="headerlink" title="控制测试运行：并行和连续执行测试"></a>控制测试运行：并行和连续执行测试</h1><p>改变cargo test的行为：添加命令行参数</p><p>默认行为：</p><ul><li>并行运行</li><li>所有测试</li><li>捕获（不显示）所有输出，使读取与测试结果相关的输出更容易<br>命令行参数：</li><li>针对cargo test的参数：紧跟cargo test后</li><li>针对测试可执行程序：放在 – 之后</li><li>cargo test –help</li><li>cargo test – –help</li></ul><h1 id="并行-连续运行测试"><a href="#并行-连续运行测试" class="headerlink" title="并行&#x2F;连续运行测试"></a>并行&#x2F;连续运行测试</h1><p>运行多个测试：默认使用多个线程并行运行</p><ul><li>运行快<br>确保测试之间：</li><li>不会互相依赖</li><li>不依赖于某个共享状态（环境，工作目录，环境变量等等）</li></ul><h2 id="–test-threads参数"><a href="#–test-threads参数" class="headerlink" title="–test-threads参数"></a>–test-threads参数</h2><p>传递给二进制文件</p><p>不想以并行运行测试，或想对线程数进行细度控制</p><p>可以使用 <code>--test-threads</code>参数，后边跟着线程的数量</p><p>例如：<code>cargo test -- --test-threads=1</code></p><h1 id="显示函数输出"><a href="#显示函数输出" class="headerlink" title="显示函数输出"></a>显示函数输出</h1><p>默认：如测试通过，rust的test库会捕获所有打印到标准输出的内容</p><p>例如：如果被测试代码中用到了println!:</p><ul><li>如果测试通过，不会在终端看到println!打印的内容</li><li>如果测试失败，会看到println!打印的内容和失败信息<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">prints_and_returns_10</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i got the value &#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">this_test_will_pass</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">prints_and_returns_10</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">10</span>, value);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">this_test_will_fail</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">prints_and_returns_10</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>,value);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行<code>cargo test</code>能看到失败中出现println!打印信息</li></ul><p>运行<code>cargo test -- --show-output</code>能看到打印所有的输出</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十四章：用should_panic检查恐慌</title>
      <link href="/2024/02/20/2024-2-20-20-39-00-rust-34/"/>
      <url>/2024/02/20/2024-2-20-20-39-00-rust-34/</url>
      
        <content type="html"><![CDATA[<h1 id="用should-panic检查恐慌"><a href="#用should-panic检查恐慌" class="headerlink" title="用should_panic检查恐慌"></a>用should_panic检查恐慌</h1><h2 id="验证错误处理的情况"><a href="#验证错误处理的情况" class="headerlink" title="验证错误处理的情况"></a>验证错误处理的情况</h2><ul><li><p>测试除了验证代码的返回值是否正确，还需验证代码是否如预期的处理了发生错误的情况</p></li><li><p>可验证代码在特定情况下是否发生了panic</p></li><li><p>should_panic属性（attribute）:</p><ul><li>函数panic：测试通过</li><li>函数没有panic：测试失败</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;&quot;</span>, value)        </span><br><span class="line">        &#125;    </span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行<code>cargo test</code>测试通过</p><p>如果测试没有出现panic则测试未通过</p><h2 id="让should-panic更精确"><a href="#让should-panic更精确" class="headerlink" title="让should_panic更精确"></a>让should_panic更精确</h2><p>为should_panic属性添加一个可选的expected参数：</p><ul><li>将检查失败消息中是否包含所指定的文字</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;&quot;</span>, value)        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;&quot;</span> , value)        </span><br><span class="line">        &#125;   </span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行<code>cargo test</code>，测试通过</p><p>恐慌内容包含以上panic的字符串，所以测试通过 ，如果不包括则测试失败</p><h1 id="在测试中使用Result"><a href="#在测试中使用Result" class="headerlink" title="在测试中使用Result&lt;T, E&gt;"></a>在测试中使用Result&lt;T, E&gt;</h1><p>无需panic，可使用<code>Result&lt;T, E&gt;</code>作为返回类型编写测试：</p><ul><li>返回OK：测试通过</li><li>返回Err：测试失败<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>+<span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行<code>cargo test</code>测试通过</p><p><strong>注意：不要在使用Result&lt;T, E&gt;编写的测试上标注#[should_panic]</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十三章：断言Assert</title>
      <link href="/2024/02/19/2024-2-19-20-59-00-rust-33/"/>
      <url>/2024/02/19/2024-2-19-20-59-00-rust-33/</url>
      
        <content type="html"><![CDATA[<h1 id="断言Assert"><a href="#断言Assert" class="headerlink" title="断言Assert"></a>断言Assert</h1><p>使用 <strong>assert!</strong> 宏检查测试结果</p><p><strong>assert!<strong>宏，来自标准库，用来确定某个状态是否为</strong>true</strong></p><ul><li>true ：测试通过</li><li>false：调用panic!,测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length &gt; other.length &amp;&amp; <span class="keyword">self</span>.width &gt; other.width    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">8</span>,</span><br><span class="line">            width: <span class="number">7</span>,        </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">5</span>,</span><br><span class="line">            width: <span class="number">1</span>,        </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：<code>cargo test</code></p><p>我们再添加测试失败的案例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length &gt; other.length &amp;&amp; <span class="keyword">self</span>.width &gt; other.width    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">8</span>,</span><br><span class="line">            width: <span class="number">7</span>,        </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">5</span>,</span><br><span class="line">            width: <span class="number">1</span>,        </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_cannot_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">8</span>,</span><br><span class="line">            width: <span class="number">7</span>,        </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            length: <span class="number">10</span>,</span><br><span class="line">            width: <span class="number">10</span>,        </span><br><span class="line">        &#125;;            </span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用assert-eq-和assert-ne-测试相等性"><a href="#使用assert-eq-和assert-ne-测试相等性" class="headerlink" title="使用assert_eq!和assert_ne!测试相等性"></a>使用assert_eq!和assert_ne!测试相等性</h2><p>都来自标准库</p><p>判断两个参数是否相等或不等</p><p>实际上，他们使用的就是 &#x3D;&#x3D; 和 !&#x3D; 运算符</p><p>断言失败：自动打印出两个参数的值</p><ul><li>使用debug格式打印参数<ul><li>要求参数实现了PartialEq和Debug Traits(所有的基本类型和标准库里大部分类型都实现了)</li></ul></li></ul><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>cargo test</code>通过</p><p>我们改为一个逻辑错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行cargo test失败，并且打印测试结果</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十二章：编写自动化测试</title>
      <link href="/2024/02/19/2024-2-19-20-55-00-rust-32/"/>
      <url>/2024/02/19/2024-2-19-20-55-00-rust-32/</url>
      
        <content type="html"><![CDATA[<h1 id="编写自动化测试"><a href="#编写自动化测试" class="headerlink" title="编写自动化测试"></a>编写自动化测试</h1><h2 id="测试（函数）"><a href="#测试（函数）" class="headerlink" title="测试（函数）"></a>测试（函数）</h2><p>测试：</p><ul><li>函数</li><li>验证非测试代码的功能是否和预期一致</li></ul><p>测试函数体（通常）执行的3个操作：</p><ul><li>准备数据&#x2F;状态</li><li>运行被测试的代码</li><li>断言（Assert）结果</li></ul><h2 id="解剖测试函数"><a href="#解剖测试函数" class="headerlink" title="解剖测试函数"></a>解剖测试函数</h2><p>测试函数需要使用test属性（attribute）进行标注</p><ul><li>Attribute就是一段Rust代码的元数据</li><li>在函数上加#[test]，可把函数编程测试函数</li></ul><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>使用cargo test命令运行所有测试函数</p><p>Rust会构建一个Test Runner可执行文件</p><p>它会运行标注了test的函数，并报告其运行是否成功</p><p>当使用cargo创建library项目的时候，会生成一个test module，里面有一个test函数</p><p>你可以添加任意数量的test module或函数</p><p>例子：<code>cargo new adder --lib</code></p><p>lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：<code>cargo test</code></p><h2 id="测试失败"><a href="#测试失败" class="headerlink" title="测试失败"></a>测试失败</h2><p>测试函数panic就表示失败</p><p>每个测试运行在一个新线程</p><p>当主线程看见某个测试线程挂掉了，那个测试标记为失败了。</p><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">exploration</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">another</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Make this test fail&quot;</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<code>cargo test</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十一章：生命周期（4）</title>
      <link href="/2024/02/11/2024-2-11-21-59-00-rust-31/"/>
      <url>/2024/02/11/2024-2-11-21-59-00-rust-31/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期（4）"><a href="#生命周期（4）" class="headerlink" title="生命周期（4）"></a>生命周期（4）</h1><h2 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h2><p>在struct上使用生命周期实现方法，语法和泛型参数的语法一样</p><p>在哪声明和使用生命周期参数，依赖于：</p><ul><li><strong>生命周期参数是否和字段、方法的参数或返回值有关</strong></li></ul><h3 id="struct字段的生命周期名："><a href="#struct字段的生命周期名：" class="headerlink" title="struct字段的生命周期名："></a>struct字段的生命周期名：</h3><ul><li>在impl后声明</li><li>在struct名后使用</li><li>这些生命周期是struct类型的一部分</li></ul><h3 id="impl块内的方法签名中："><a href="#impl块内的方法签名中：" class="headerlink" title="impl块内的方法签名中："></a>impl块内的方法签名中：</h3><ul><li>引用必须绑定与struct字段引用的生命周期，或者引用是独立的也可以</li><li>生命周期省略规则经常使得方法中的生命周期标注不是必须的<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;    <span class="comment">//这里没有省略生命周期，所以self中可以不标注生命周期</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p><code>‘static </code>是一个特殊的生命周期：整个程序的持续时间。</p><p>例如：所有的字符串字面值都拥有<code>&#39;static生命周期</code></p><p><code>let s: &amp;&#39;static str = &quot;i have a static lifetime&quot;</code></p><p>为引用指定’static生命周期前要三思：</p><ul><li><strong>是否需要引用在程序整个生命周期内都存活</strong></li></ul><h2 id="泛型参数类型、Trait-Bound、生命周期"><a href="#泛型参数类型、Trait-Bound、生命周期" class="headerlink" title="泛型参数类型、Trait Bound、生命周期"></a>泛型参数类型、Trait Bound、生命周期</h2><p>综合例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line">    (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T:Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement!, &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第三十章：生命周期（3）</title>
      <link href="/2024/02/10/2024-2-10-1-06-00-rust-30/"/>
      <url>/2024/02/10/2024-2-10-1-06-00-rust-30/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期（3）"><a href="#生命周期（3）" class="headerlink" title="生命周期（3）"></a>生命周期（3）</h1><h1 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h1><p>指定生命周期参数的方式依赖于函数所做的事情</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>()&#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的返回值的生命周期跟x与y有关系，所以，x与y的生命周期我们标注了一下</p><p>如果改为一下方式，甚至就不需要每个参数都标注生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数返回引用时，返回类型生命周期参数需要与其中一个参数的生命周期匹配：</p><p>如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值：</p><ul><li>这就是悬垂引用：该值在函数结束时就走出了作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    result.<span class="title function_ invoke__">as_str</span>()    <span class="comment">//这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码生命周期不够，因为返回的生命周期仍然是内部的引用的生命周期</p><p>所以这样改就能获得了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;<span class="comment">//相当于把所有权交给返回值了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    result    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Struct-定义中的生命周期标注"><a href="#Struct-定义中的生命周期标注" class="headerlink" title="Struct 定义中的生命周期标注"></a>Struct 定义中的生命周期标注</h1><p>Struct里可包括：</p><ul><li>自持有的类型</li><li>引用：需要在每个引用上添加生命周期标注</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael, Some years ago...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">next</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt&#123;</span><br><span class="line">        part: first_sentence    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h1><p>我们知道：</p><ul><li>每个引用都有生命周期</li><li>需要为使用生命周期的函数或struct指定生命周期参数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span>(i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>在rust引用分析中所编入的模式成为生命周期省略规则</p><ul><li>这些规则无需开发者来遵守</li><li>它们事一些特殊情况，由编译器来考虑</li><li>如果你的代码符合这些情况，那么就无需显式标注生命周期</li></ul><p>生命周期省略规则不会提供完整的推断：</p><ul><li>如果应用规则后，引用的生命周期仍然模糊不清 -&gt; 编译错误</li><li>解决办法：添加生命周期标注，表明引用间的互相关系</li></ul><h1 id="输入、输出生命周期"><a href="#输入、输出生命周期" class="headerlink" title="输入、输出生命周期"></a>输入、输出生命周期</h1><p>生命周期在：</p><ul><li>函数&#x2F;方法的参数：输入生命周期</li><li>函数&#x2F;方法的返回值：输出生命周期</li></ul><h1 id="生命周期省略的三个规则"><a href="#生命周期省略的三个规则" class="headerlink" title="生命周期省略的三个规则"></a>生命周期省略的三个规则</h1><p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期</p><ul><li>规则1应用于输入生命周期</li><li>规则2.3应用于输出生命周期</li><li>如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用 -&gt; 报错</li><li>这些规则适用于fn定义和impl块</li></ul><p><strong>规则1：每个引用类型的参数都有自己的生命周期</strong></p><p><strong>规则2：如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期</strong></p><p><strong>规则3：如果有多个输入生命周期参数，但其中一个事&amp;self或&amp;mut self（是方法），那么self的生命周期会被赋给所有的输出生命周期参数</strong></p><h1 id="生命周期省略的三个规则-例子"><a href="#生命周期省略的三个规则-例子" class="headerlink" title="生命周期省略的三个规则 - 例子"></a>生命周期省略的三个规则 - 例子</h1><p>假设我们是编译器：</p><ul><li><p>fn first_word(s: &amp;str) -&gt; &amp;str {</p></li><li><p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;str {</p></li><li><p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str {</p></li><li><p>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</p></li><li><p>fn longest&lt;’a, ‘b&gt;(x: &amp;’a str, y:&amp;’b str) -&gt; &amp;str {</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十九章：生命周期(2)</title>
      <link href="/2024/02/08/2024-2-8-23-41-00-rust-29/"/>
      <url>/2024/02/08/2024-2-8-23-41-00-rust-29/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期（2）"><a href="#生命周期（2）" class="headerlink" title="生命周期（2）"></a>生命周期（2）</h1><h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><p>生命周期的标注不会改变引用的生命周期长度</p><p>当指定了泛型生命周期参数，函数可以接受带有任何生命周期的引用</p><p>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期</p><h2 id="生命周期标注–语法"><a href="#生命周期标注–语法" class="headerlink" title="生命周期标注–语法"></a>生命周期标注–语法</h2><h3 id="生命周期参数名："><a href="#生命周期参数名：" class="headerlink" title="生命周期参数名："></a>生命周期参数名：</h3><ul><li>以 ’ 开头</li><li>通常全小写且非常短</li><li>很多人使用 ‘a</li></ul><h3 id="生命周期标注的位置："><a href="#生命周期标注的位置：" class="headerlink" title="生命周期标注的位置："></a>生命周期标注的位置：</h3><ul><li><p>在引用的 &amp; 符号后</p></li><li><p>使用空格将标注和引用类型分开</p></li></ul><h3 id="生命周期标注-例子"><a href="#生命周期标注-例子" class="headerlink" title="生命周期标注 - 例子"></a>生命周期标注 - 例子</h3><ul><li>&amp;i32 &#x2F;&#x2F;一个引用</li><li>&amp;‘a i32 &#x2F;&#x2F;带有显式生命周期的引用</li><li>&amp;’a mut i32     &#x2F;&#x2F;带有显式生命周期的可变引用</li></ul><p><strong>单个生命周期标注本身没有意义</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h2><ul><li>泛型生命周期参数声明在：函数名和参数列表之间的&lt;&gt;里</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());    <span class="comment">//这里会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上这种情况就会出现错误，longest函数返回值的生命周期取得是x，y中生命周期最短的那一个，代码中能看出string2的生命周期是最短的，所以string2已经离开了作用域导致result无法取得其值进行使用</p><p>编译代码的时候会提示string2的生命周期不够长，在花括号结束的时候string2离开了作用域，但是它仍然处于被借用的状态。</p><p><strong>生命周期 ‘a 的实际生命周期是：x和y两个生命周期中比较小的那个</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十八章：生命周期(1)</title>
      <link href="/2024/02/07/2024-2-7-20-54-00-rust-28/"/>
      <url>/2024/02/07/2024-2-7-20-54-00-rust-28/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期（1）"><a href="#生命周期（1）" class="headerlink" title="生命周期（1）"></a>生命周期（1）</h1><p>Rust的每个引用都有自己的生命周期</p><p>生命周期：引用保持有效的作用域</p><p>大多数情况：生命周期是隐式的，可被推断的</p><p>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</p><h2 id="生命周期-避免悬垂引用（dangling-reference）"><a href="#生命周期-避免悬垂引用（dangling-reference）" class="headerlink" title="生命周期 - 避免悬垂引用（dangling reference）"></a>生命周期 - 避免悬垂引用（dangling reference）</h2><p>生命周期的主要目标：避免悬垂引用（dangling reference）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;<span class="comment">//未被初始化，不是null，未被使用。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">            r = &amp;x;  <span class="comment">//这里会报错      </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//在使用r的时候，x已经结束作用域了，x的内存已经被释放   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ----------+-- &#x27;a</span></span><br><span class="line">        &#123;                     <span class="comment">//           /</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// --+-- &#x27;b  /</span></span><br><span class="line">            r = &amp;x;           <span class="comment">//   /       /</span></span><br><span class="line">        &#125;                     <span class="comment">// --+       /</span></span><br><span class="line">                              <span class="comment">//           /</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//           /</span></span><br><span class="line">    &#125;                         <span class="comment">//-----------/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要解决这个问题，至少让<strong>生命周期b</strong>不小于<strong>a</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译以上代码会出现错误</p><p>会提示</p><p><strong>缺少生命周期的标注，在返回类型会提示缺少命名的生命周期参数。</strong></p><p><strong>函数的返回类型包含了一个借用的值，但是不知道这个值是来自x还是来自y。</strong></p><p><strong>帮助：考虑引入一个命名的生命周期参数</strong></p><p><code>在函数中，longest函数是不知道参数x和y的生命周期，没办法通过比较作用域来比较生命周期</code></p><p>如果将代码改成如下，还是会提示同一个错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以能看出，<strong>生命周期跟函数体内部的逻辑是没有关系的，跟函数签名有关系</strong></p><p>根据帮助的提示，我们将代码改成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原因下一章讲解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十七章：Trait(下)</title>
      <link href="/2024/02/06/2024-2-6-21-13-00-rust-27/"/>
      <url>/2024/02/06/2024-2-6-21-13-00-rust-27/</url>
      
        <content type="html"><![CDATA[<h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><ul><li>Trait作为参数</li></ul><h2 id="impl-Trait语法：适用于简单情况"><a href="#impl-Trait语法：适用于简单情况" class="headerlink" title="impl Trait语法：适用于简单情况"></a>impl Trait语法：适用于简单情况</h2><p>先来看例子<br>lib.rs文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;    <span class="comment">//当把Summary for去掉，就是为类型实现方法,加上之后就是为这个类型实现trait</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">         <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trait-bound语法：可用于复杂情况"><a href="#Trait-bound语法：可用于复杂情况" class="headerlink" title="Trait bound语法：可用于复杂情况"></a>Trait bound语法：可用于复杂情况</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种impl写法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span>, item2:<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item1.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种 trait bound语法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T:Summary&gt;(item1:T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>impl trait语法是Trait bound的语法糖</li></ul><h2 id="使用-指定多个trait-bound"><a href="#使用-指定多个trait-bound" class="headerlink" title="使用 + 指定多个trait bound"></a>使用 + 指定多个trait bound</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item1.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T:Summary + Display&gt;(item1:T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item1.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trait-bound-使用where子句"><a href="#Trait-bound-使用where子句" class="headerlink" title="Trait bound 使用where子句"></a>Trait bound 使用where子句</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify2</span>&lt;T, U&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在方法签名后指定where子句</li></ul><h2 id="实现Trait作为返回类型"><a href="#实现Trait作为返回类型" class="headerlink" title="实现Trait作为返回类型"></a>实现Trait作为返回类型</h2><p>impl Trait语法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;    <span class="comment">//当把Summary for去掉，就是为类型实现方法,加上之后就是为这个类型实现trait</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">         <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best hockey team in the NHL.&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上写法会有漏洞：</span></span><br><span class="line">因为Summary有多个Trait，所以如果<span class="keyword">trait</span>实现是多个返回具体类型的可能，这种情况就会报错</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(flag： <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">      NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best hockey team in the NHL.&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Tweet &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best hockey team in the NHL.&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： impl Trait只能返回确定的同一种类型，返回可能不同类型的代码会报错</strong></p><p>使用Trait Bound的例子</p><ul><li>使用Trait Bound修复largest函数</li></ul> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;<span class="comment">//光加入PartialOrd还有其他错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];                <span class="comment">//适合存在栈上的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;    <span class="comment">//std::cmp::PartialOrd</span></span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存储在堆上数据:</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;<span class="comment">//光加入PartialOrd还有其他错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();                <span class="comment">//适合存在堆上的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;    <span class="comment">//std::cmp::PartialOrd</span></span><br><span class="line">            largest = item.<span class="title function_ invoke__">clone</span>();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者是直接下面这样</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;<span class="comment">//光加入PartialOrd还有其他错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];                <span class="comment">//适合存在堆上的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;    <span class="comment">//std::cmp::PartialOrd</span></span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;str_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Trait-Bound有条件的实现方法"><a href="#使用Trait-Bound有条件的实现方法" class="headerlink" title="使用Trait Bound有条件的实现方法"></a>使用Trait Bound有条件的实现方法</h2><p>在使用泛型类型参数的impl块上使用Trait bound，我们可以有条件的为实现了特定Trait的类型来实现方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y:T) <span class="punctuation">-&gt;</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;x, y&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y  &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;the largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以为实现了其他Trait的任意类型有条件的实现<strong>某个trait</strong></p><p>为满足<strong>Trait Bound</strong>的所有类型上实现Trait叫做<strong>覆盖实现</strong>（blanket implementations）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看标准库string.rs</span></span><br><span class="line"><span class="comment">//2192行</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: fmt::Display + ?<span class="built_in">Sized</span>&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    default <span class="keyword">fn</span> <span class="title function_">to_string</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> fmt::Write;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        buf.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;a Display implementation returned an error unexpectedly&quot;</span>);    </span><br><span class="line">        buf.<span class="title function_ invoke__">shrink_to_fit</span>();</span><br><span class="line">        buf               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述标准库中为所有<strong>Display</strong>类型实现了ToString方法</p><p>具体我们<strong>用自己的例子</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>= <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十六章：Trait(上)</title>
      <link href="/2024/02/05/2024-2-5-21-35-00-rust-26/"/>
      <url>/2024/02/05/2024-2-5-21-35-00-rust-26/</url>
      
        <content type="html"><![CDATA[<h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><p>trait告诉Rust编译器</p><ul><li>某种类型具有哪些并且可以与其他类型共享的功能</li></ul><p>trait：抽象的定义共享行为</p><p>trait bounds：泛型类型参数指定为实现了特定行为的类型</p><p>trait与其他语言的接口（interface）类似，但有些区别</p><h1 id="定义一个Trait"><a href="#定义一个Trait" class="headerlink" title="定义一个Trait"></a>定义一个Trait</h1><p>Trait的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为。</p><ul><li><p>关键字：trait</p></li><li><p>只有方法签名，没有具体实现</p></li><li><p>trait可以有多个方法：每个方法签名占一行，以分号结尾</p></li><li><p>实现该trait的类型必须提供具体的方法实现</p></li></ul> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize1</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewsArticle</span></span><br><span class="line"><span class="comment">//Tweet</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>在<strong>类型</strong>上实现trait</p><ul><li>与为类型实现方法类似。</li><li>不同之处：<ul><li>impl Xxxx for Tweet {…}</li><li>在impl的块里，需要对Trait里的方法签名进行具体的实现</li></ul></li></ul><p><strong>lib.rs文件：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;    <span class="comment">//当把Summary for去掉，就是为类型实现方法,加上之后就是为这个类型实现trait</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">         <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.rs</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo::Summary;</span><br><span class="line"><span class="keyword">use</span> demo::Tweet;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现trait的约束"><a href="#实现trait的约束" class="headerlink" title="实现trait的约束"></a>实现trait的约束</h1><p>可以在某个类型上实现某个trait的前提条件是：</p><ul><li>这个类型或这个trait是在本地crate里定义的</li></ul><p>无法为外部类型来实现外部的trait：</p><ul><li>这个限制是程序属性的一部分（也就是一致性）</li><li>更具体地说是孤儿规则：之所以这样命名是因为夫类型不存在。</li><li>此规则确保其他人的代码不能破坏您的代码，反之亦然。</li><li>如果没有这个规则，两个crate可以为同一类型实现同一个trait，Rust就不知道应该使用哪个实现了。</li></ul><h1 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h1><p><strong>lib.rs：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="comment">//fn summarize(&amp;self) -&gt; String;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)    <span class="comment">//默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;  </span><br><span class="line">    <span class="comment">//fn summarize(&amp;self) -&gt; String &#123;</span></span><br><span class="line">    <span class="comment">//    format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)    </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">         <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.rs：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo::NewsArticle;</span><br><span class="line"><span class="keyword">use</span> demo::Summary;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Pittsburgh Penguins once again are the best hockey team in the NHL.&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet： &#123;&#125;&quot;</span>， article.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认实现的方法可以调用trait中其他的方法，即使这些方法没有<strong>默认实现</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)    <span class="comment">//默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;  </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;    <span class="comment">//具体实现</span></span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">         <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：无法从方法的重写实现里调用默认的实现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十五章：泛型</title>
      <link href="/2024/02/04/2024-2-4-21-54-00-rust-25/"/>
      <url>/2024/02/04/2024-2-4-21-54-00-rust-25/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型：提高代码复用能力</p><ul><li>处理重复代码的问题</li></ul><p>泛型是具体类型或其他属性的抽象代替</p><ul><li>你编写的代码不是最终的代码，而是一种模板，里边有一些“占位符”</li><li>编译器在编译时将占位符替换为具体的类型。</li></ul><p>例如：fn largest<T>(list: &amp;[T]) -&gt; T {…}</p><p>类型参数：</p><ul><li>很短，通常一个字母</li><li>CamelCase</li><li>T：type的缩写</li></ul><h2 id="函数定义中的泛型"><a href="#函数定义中的泛型" class="headerlink" title="函数定义中的泛型"></a>函数定义中的泛型</h2><p>泛型函数：</p><ul><li>参数类型</li><li>返回类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//largest函数并不能应用在字符型的代码中,所以以下代码会报错,因此使用泛型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>使用泛型补充函数定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的写法还不够，在编译运行还会提示报错，会提示，不是所有类型都能使用比较符号来比较大小。</p><p>同时编译器会提示使用以下方式来定义函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是代码还是会在第四行报错，但是这里需要留到后边讲了</p><h2 id="结构体泛型"><a href="#结构体泛型" class="headerlink" title="结构体泛型"></a>结构体泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Poing</span>&lt;T， U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Poing &#123;x:<span class="number">5</span>, y:<span class="number">1.0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用多个泛型的类型参数</p><ul><li>太多类型参数：你的代码需要重组为多个更小的单元</li></ul><h2 id="Enum定义中的泛型"><a href="#Enum定义中的泛型" class="headerlink" title="Enum定义中的泛型"></a>Enum定义中的泛型</h2><ul><li>可以让枚举的变体持有泛型数据类型</li><li>例如Option<T>, Result&lt;T, E&gt;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h2><p>为struct或enum实现方法的时候，可以在定义中使用泛型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x1</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Poing &#123;x:<span class="number">5</span>, y:<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>把T放在impl关键字后，表示在类型T上实现方法<ul><li>例如:impl<T> Poing<T></li></ul></li><li>只针对具体类型实现方法（其余类型没实现方法）：<ul><li>例如：impl Poing<f32></li></ul></li></ul><p>struct 里的泛型类型参数可以和方法的泛型类型参数不同</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<span class="comment">//注意返回类型第一个类型使用struct类型，第二个返回方法的类型</span></span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,                    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123;x: <span class="number">5</span>, y: <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point&#123;x: <span class="string">&quot;hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h1><p>使用泛型的代码和使用具体类型的代码运行速度是一样的。</p><h2 id="单态化"><a href="#单态化" class="headerlink" title="单态化"></a>单态化</h2><ul><li>在编译时将泛型替换为具体类型的过程</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fn main() &#123;</span></span><br><span class="line"><span class="comment">//    let integer = Some(5);</span></span><br><span class="line"><span class="comment">//    let float = Some(5.0);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//在编译时，编译器会将上述泛型转换为类似下边代码的方式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Rust】第二十四章：消除重复代码</title>
      <link href="/2024/02/04/2024-2-4-21-50-00-rust-24/"/>
      <url>/2024/02/04/2024-2-4-21-50-00-rust-24/</url>
      
        <content type="html"><![CDATA[<h1 id="提取函数以消除重复代码"><a href="#提取函数以消除重复代码" class="headerlink" title="提取函数以消除重复代码"></a>提取函数以消除重复代码</h1><p>找出数组中最大值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = number_list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest number is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">    <span class="comment">//如果说从另一个数组中找出最大值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">100</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = number_list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the largest number is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就有重复代码了，整理成函数来使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;    <span class="comment">//引用符号</span></span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上代码还可以这样写</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;    <span class="comment">//引用符号</span></span><br><span class="line">        <span class="keyword">if</span> *item &gt; largest &#123;</span><br><span class="line">            largest = *item;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消除重复的步骤"><a href="#消除重复的步骤" class="headerlink" title="消除重复的步骤"></a>消除重复的步骤</h1><p>1.识别重复代码</p><p>2.提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值</p><p>3.将重复的代码使用函数调用进行替代</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现一个小型消息队列</title>
      <link href="/2023/12/22/2023-12-22-22-32-00-Queue/"/>
      <url>/2023/12/22/2023-12-22-22-32-00-Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言实现一个小型消息队列（可移植）"><a href="#C语言实现一个小型消息队列（可移植）" class="headerlink" title="C语言实现一个小型消息队列（可移植）"></a>C语言实现一个小型消息队列（可移植）</h1><p>本着能有一个<code>占内存小</code>，<code>方便使用</code>、<code>移植</code>的几个方向，我写了这个小型的消息队列，同时也应用在了我工作中开发的项目里。</p><h2 id="结构部分"><a href="#结构部分" class="headerlink" title="结构部分"></a>结构部分</h2><h3 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h3><p>使用循环队列，定义一个结构体，里边有<code>数据区</code>,<code>头尾指针</code>,最好还是能有个存储数据<code>大小</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_t</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tail;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> size;</span><br><span class="line">&#125;<span class="type">queue_t</span>;</span><br></pre></td></tr></table></figure><p>为了方便知晓存储数据长度，干脆就直接定义一个变量存储数据长度，而不用那种头尾指针计算方式获取。</p><h3 id="存储数据区域"><a href="#存储数据区域" class="headerlink" title="存储数据区域"></a>存储数据区域</h3><p>推荐使用<code>静态</code>全局变量数组来当数据结构的区域，这部分空间不会被回收，也不会被其他模块占用，<strong>我不推荐在结构体中直接定义数组空间</strong>，某些编译器会优化结构体中的数组空间造成这部分空间与其他变量会有冲突，而且容易被其他模块所修改，所以我们开辟一个<code>static修饰</code>的静态数组空间，保证这个空间不会被其他访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_NUM   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_MAX   256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(QUEUE_LIST_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_LIST_SIZE (sizeof(char)*QUEUE_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="built_in">queue</span>[QUEUE_LIST_SIZE][QUEUE_MAX]; <span class="comment">// 数据区</span></span><br><span class="line"><span class="type">static</span> <span class="type">queue_t</span> queue_fifo[QUEUE_LIST_SIZE];    <span class="comment">// 队列区</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> queue_mask;               <span class="comment">// MASK</span></span><br></pre></td></tr></table></figure><p>预留出几组空间，关于QUEUE_LIST_SIZE与QUEUE_MAX两个完全是由开发者自己修改的宏。但是我为了方便，尽量开辟了最小能满足的大小。</p><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>这个纯粹是为了调用方便来规定的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">QUEUE_ERR</span>&#123;</span></span><br><span class="line">    QUEUE_ERR_OK = <span class="number">0</span>,   <span class="comment">//OK</span></span><br><span class="line">    QUEUE_ERR_MAXLEN,   <span class="comment">//OVER MAX SIZE</span></span><br><span class="line">    QUEUE_ERR_OVERLEN,  <span class="comment">//OVER LEFT SIZE</span></span><br><span class="line">    QUEUE_ERR_FULL,     <span class="comment">//FULL</span></span><br><span class="line">    QUEUE_ERR_EMPTY,    <span class="comment">//EMPTY</span></span><br><span class="line">    QUEUE_ERR_MEM,</span><br><span class="line">    QUEUE_ERR_DATA,</span><br><span class="line">&#125;QUEUE_ERR_e;</span><br></pre></td></tr></table></figure><p>也不知道以后会不会增加新的，目前能用到的也就这些返回码</p><h2 id="接口部分"><a href="#接口部分" class="headerlink" title="接口部分"></a>接口部分</h2><p>按照模块化的思想，考虑到能给其他模块使用，最好是提供出来以下接口：</p><p><code>注册</code>，<code>入队列</code>，<code>出队列</code>，<code>注销</code>。</p><p>以上四个模块是最基本的能供给其他模块调用。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册队列当然是从我们之前定义的那几组<code>queue_fifo</code>中获取空闲的一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 注册一个队列</span></span><br><span class="line"><span class="comment"> * @param null</span></span><br><span class="line"><span class="comment"> * @return 队列指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">queue_t</span> *<span class="title function_">queue_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="type">queue_t</span> *p_queue;</span><br><span class="line">    <span class="keyword">for</span> (id = <span class="number">0</span>; id &lt; QUEUE_LIST_SIZE; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((queue_mask &gt;&gt; id) &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (QUEUE_LIST_SIZE == id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;there is no queue could be alloc\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_mask |= (<span class="number">1</span> &lt;&lt; id);</span><br><span class="line">    p_queue = &amp;queue_fifo[id];</span><br><span class="line">    p_queue-&gt;<span class="built_in">queue</span> = <span class="built_in">queue</span>[id];</span><br><span class="line">    p_queue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    p_queue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    p_queue-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// QUEUE_PRI_LOG(p_queue);</span></span><br><span class="line">    <span class="keyword">return</span> p_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学过c语言的人我觉得这个应该轻轻松松就能看懂，没学过我也解释下吧。<br>我们之前在队列空间与数据空间的时候不是一块定义了<code>queue_mask</code>吗，这个就在这里用到了，当作一个掩码来管理队列空间，注意他是char类型，8个bit位，每一位只能是<code>0</code>或<code>1</code>，这就很好提供了一个管理思路，这个队列被使用，对应掩码中这位为<code>1</code>，没有被使用就是<code>0</code>。</p><p>所以上边的注册就是从掩码中取最小的一位<code>0</code>所在的位置，用这个位置来当作我要取的队列空间的位置。如果为<code>1</code>，我就向右偏移找<code>0</code>在的位置，找到就取队列空间与数据空间，如果全部都没有，证明队列已经被注册完了，返回空，所以在<strong>调用注册的时候，注意判断是不是空</strong>。</p><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><p>上边的在注册时候我们定义了一个id来获取空的队列空间与数据空间，但是这个id是注册接口内部使用的，我们不能在注销中使用注册空间内部的数据，有人问：那为什么不在外部定义一个id？，对不起，这个id并没有很多经常使用的地方，所以就不在定义了。</p><p>那我们怎么获取id呢，按照队列注册的思路，传入参数我们只传一个<code>queue_fifo</code>的指针。我们能知道<code>queue_fifo</code>中有一个被使用，同时数据空间<code>queue</code>也有一个被使用，但是id我们不知道，考虑能方便被其他模块调用<br>，但是我们知道queue_fifo中对应的queue是在数据空间中，他们的<code>地址</code>是一样的，所以按照这个思路在注销中能搜到这个空间来注销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 注销队列</span></span><br><span class="line"><span class="comment"> * @param queue_list    队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_uninit</span><span class="params">(<span class="type">queue_t</span> *queue_list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!queue_list || !queue_list-&gt;<span class="built_in">queue</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_MEM;</span><br><span class="line">    <span class="keyword">if</span> (queue_list-&gt;size != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_DATA;</span><br><span class="line">    j = QUEUE_LIST_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue_list-&gt;<span class="built_in">queue</span> == <span class="built_in">queue</span>[i])</span><br><span class="line">        &#123;</span><br><span class="line">            queue_mask &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue_list-&gt;<span class="built_in">queue</span> == <span class="built_in">queue</span>[j])</span><br><span class="line">        &#123;</span><br><span class="line">            queue_mask &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_list-&gt;<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开头的几个条件判断就不谈了，我定义了两个指针<code>i</code>,<code>j</code>，这样循环次数能减少一半，如果发现queue_fifo中queue地址与数据空间queue对应的地址一样我们就把queue_mask中的那位<code>清0</code>，清零就是我们注销了，然后跳出循环。</p><p>为了指针的安全性，这个queue_list中指向数据区的指针我们也清空.</p><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向队列存储数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_push</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; QUEUE_MAX - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_MAXLEN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head != <span class="built_in">queue</span>-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; (QUEUE_MAX - <span class="built_in">queue</span>-&gt;size - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> QUEUE_ERR_FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % QUEUE_MAX;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[<span class="built_in">queue</span>-&gt;tail] = buff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += len;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始进行条件判断，如果入数据长度比队列长度还长就返回超长的错误码。<br>另一个如果队列中有数据，判断入数据长度与队列剩余空间的长度。如果这两个都通过了，我们可以将这个数据入到队列里。</p><p>既然是数组空间，那为了<strong>防止溢出，我们要浪费掉一个空间来判断队列是不是满</strong>，这个是通用的手法。</p><p><strong>入队列就是尾指针向后移动</strong>，如果超过队列最大下标，那就从头开始，这样，我们不用担心数据会跑出这个空间。最后返回成功。</p><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从队列中取数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储取出数据指针</span></span><br><span class="line"><span class="comment"> * @param len 要取出数据长度</span></span><br><span class="line"><span class="comment"> * @return 真正取出的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">queue_pop</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">    <span class="type">int</span> pop_len = (len &gt; <span class="built_in">queue</span>-&gt;size) ? <span class="built_in">queue</span>-&gt;size : len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pop_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % QUEUE_MAX;</span><br><span class="line">        buff[i] = <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= pop_len;</span><br><span class="line">    <span class="keyword">return</span> pop_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队列与入队列差不多，<strong>先判断一样有没有数据</strong>，如果有数据我们就向下走，取队列中存储的数据长度与要取出的长度，<strong>取最小的值</strong>，然后按照这个值来循环，依次存入buff中，然后将<strong>队列数据大小减掉取出的长度</strong>，最后返回取出的<strong>实际长度</strong>。</p><p>这样，这个队列模块就完成了，可移植到内存小的设备中使用。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>queue.c文件的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="built_in">queue</span>[QUEUE_LIST_SIZE][QUEUE_MAX]; <span class="comment">// queuedata</span></span><br><span class="line"><span class="type">static</span> <span class="type">queue_t</span> queue_fifo[QUEUE_LIST_SIZE];    <span class="comment">// queuelist</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> queue_mask;               <span class="comment">// MASK</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">QUEUE_PRI_LOG</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue id is [%#x]\n&quot;</span>, queue_mask);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue size is [%d]\n&quot;</span>, <span class="built_in">queue</span>-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 注册一个队列</span></span><br><span class="line"><span class="comment"> * @param null</span></span><br><span class="line"><span class="comment"> * @return 队列指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">queue_t</span> *<span class="title function_">queue_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="type">queue_t</span> *p_queue;</span><br><span class="line">    <span class="keyword">for</span> (id = <span class="number">0</span>; id &lt; QUEUE_LIST_SIZE; id++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((queue_mask &gt;&gt; id) &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (QUEUE_LIST_SIZE == id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;there is no queue could be alloc\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_mask |= (<span class="number">1</span> &lt;&lt; id);</span><br><span class="line">    p_queue = &amp;queue_fifo[id];</span><br><span class="line">    p_queue-&gt;<span class="built_in">queue</span> = <span class="built_in">queue</span>[id];</span><br><span class="line">    p_queue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    p_queue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    p_queue-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// QUEUE_PRI_LOG(p_queue);</span></span><br><span class="line">    <span class="keyword">return</span> p_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向队列存储数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_push</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; QUEUE_MAX - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_MAXLEN;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head != <span class="built_in">queue</span>-&gt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; (QUEUE_MAX - <span class="built_in">queue</span>-&gt;size - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> QUEUE_ERR_FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % QUEUE_MAX;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[<span class="built_in">queue</span>-&gt;tail] = buff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size += len;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从队列中取数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储取出数据指针</span></span><br><span class="line"><span class="comment"> * @param len 取出数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">queue_pop</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">    <span class="type">int</span> pop_len = (len &gt; <span class="built_in">queue</span>-&gt;size) ? <span class="built_in">queue</span>-&gt;size : len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pop_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % QUEUE_MAX;</span><br><span class="line">        buff[i] = <span class="built_in">queue</span>-&gt;<span class="built_in">queue</span>[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size -= pop_len;</span><br><span class="line">    <span class="keyword">return</span> pop_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 注销队列</span></span><br><span class="line"><span class="comment"> * @param queue_list    队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_uninit</span><span class="params">(<span class="type">queue_t</span> *queue_list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!queue_list || !queue_list-&gt;<span class="built_in">queue</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_MEM;</span><br><span class="line">    <span class="keyword">if</span> (queue_list-&gt;size != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> QUEUE_ERR_DATA;</span><br><span class="line">    j = QUEUE_LIST_SIZE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue_list-&gt;<span class="built_in">queue</span> == <span class="built_in">queue</span>[i])</span><br><span class="line">        &#123;</span><br><span class="line">            queue_mask &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue_list-&gt;<span class="built_in">queue</span> == <span class="built_in">queue</span>[j])</span><br><span class="line">        &#123;</span><br><span class="line">            queue_mask &amp;= ~(<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_list-&gt;<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 测试 */</span></span><br><span class="line">    <span class="type">queue_t</span> *queue1 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue2 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue3 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue4 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue5 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue6 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue7 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue8 = queue_init();</span><br><span class="line">    queeu_uninit(queue7);</span><br><span class="line">    queeu_uninit(queue8);</span><br><span class="line">    <span class="type">queue_t</span> *queue9 = queue_init();</span><br><span class="line">    <span class="type">queue_t</span> *queue10 = queue_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buff1[<span class="number">64</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff2[<span class="number">32</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff_pop1[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> buff_pop2[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    queue_push(queue9, buff1, <span class="keyword">sizeof</span>(buff1));</span><br><span class="line">    queue_push(queue10, buff2, <span class="keyword">sizeof</span>(buff2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue9 size [%d]\n&quot;</span>, queue9-&gt;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue10 size [%d]\n&quot;</span>, queue10-&gt;size);</span><br><span class="line"></span><br><span class="line">    queue_pop(queue9, buff_pop1, <span class="number">5</span>);</span><br><span class="line">    queue_pop(queue10, buff_pop2, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff_pop1 is [%s]\n&quot;</span>, buff_pop1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff_pop2 is [%s]\n&quot;</span>, buff_pop2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buff_pop1); i++)</span><br><span class="line">        buff_pop1[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buff_pop2); i++)</span><br><span class="line">        buff_pop2[i] = <span class="number">0</span>;</span><br><span class="line">    queue_pop(queue9, buff_pop1, <span class="keyword">sizeof</span>(buff_pop1));</span><br><span class="line">    queue_pop(queue10, buff_pop2, <span class="keyword">sizeof</span>(buff_pop2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff_pop1 is [%s]\n&quot;</span>, buff_pop1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff_pop2 is [%s]\n&quot;</span>, buff_pop2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>queue.h文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_NUM   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_MAX   256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(QUEUE_LIST_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_LIST_SIZE (sizeof(char)*QUEUE_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_LIST_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_t</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tail;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> size;</span><br><span class="line">&#125;<span class="type">queue_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">QUEUE_ERR</span>&#123;</span></span><br><span class="line">    QUEUE_ERR_OK = <span class="number">0</span>,   <span class="comment">//OK</span></span><br><span class="line">    QUEUE_ERR_MAXLEN,   <span class="comment">//OVER MAX SIZE</span></span><br><span class="line">    QUEUE_ERR_OVERLEN,  <span class="comment">//OVER LEFT SIZE</span></span><br><span class="line">    QUEUE_ERR_FULL,     <span class="comment">//FULL</span></span><br><span class="line">    QUEUE_ERR_EMPTY,    <span class="comment">//EMPTY</span></span><br><span class="line">    QUEUE_ERR_MEM,</span><br><span class="line">    QUEUE_ERR_DATA,</span><br><span class="line">&#125;QUEUE_ERR_e;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向队列存储数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_push</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从队列中取数据</span></span><br><span class="line"><span class="comment"> * @param queue 队列</span></span><br><span class="line"><span class="comment"> * @param buff 存储取出数据指针</span></span><br><span class="line"><span class="comment"> * @param len 取出数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">queue_pop</span><span class="params">(<span class="type">queue_t</span> *<span class="built_in">queue</span>, <span class="type">char</span> *buff, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 注销队列</span></span><br><span class="line"><span class="comment"> * @param queue_list    队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QUEUE_ERR_e <span class="title function_">queue_uninit</span><span class="params">(<span class="type">queue_t</span> *queue_list)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux C】http服务器</title>
      <link href="/2023/09/27/2023-9-27-21-40-11-c-althttp/"/>
      <url>/2023/09/27/2023-9-27-21-40-11-c-althttp/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP服务器-Linux-C"><a href="#HTTP服务器-Linux-C" class="headerlink" title="HTTP服务器 Linux C"></a>HTTP服务器 Linux C</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>公司项目终于整完了，有时间闲下来搞Linux了，这次这个代码是我很久之前刷到的一个HTTP服务器的代码，作者是<code>Richard Hipp</code>，不太熟悉是吧？<strong>sqlite数据库</strong>搞嵌入式工作的伙伴应该都熟悉，也就是同一个作者，并且<strong>Althttp</strong>项目是作者最近几年才公开代码，整个Althttp服务器<strong>源代码只有一个c文件，代码量3679行</strong>，里边有http服务，tls，非常适合个人学习，相比nginx来说，对新人更友好，并且作者在代码里边每个部分都有注释，我是做单片机工作的，但是对linux开发也有兴趣，所以，这个文章我会发布与<strong>Althttpd</strong>项目的学习过程，搭配chatgpt一块来学习。</p><h2 id="第一部分：项目介绍"><a href="#第一部分：项目介绍" class="headerlink" title="第一部分：项目介绍"></a>第一部分：项目介绍</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** 2001-09-15</span><br><span class="line">**</span><br><span class="line">** The author disclaims copyright to this source code.  In place of</span><br><span class="line">** a legal notice, here is a blessing:</span><br><span class="line">**</span><br><span class="line">**    May you do good and not evil.</span><br><span class="line">**    May you find forgiveness for yourself and forgive others.</span><br><span class="line">**    May you share freely, never taking more than you give.</span><br><span class="line">**</span><br><span class="line"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span><br><span class="line">**</span><br><span class="line">** This source code file implements a small, simple, stand-alone HTTP</span><br><span class="line">** server.  </span><br><span class="line">**</span><br><span class="line">** Features:</span><br><span class="line">**</span><br><span class="line">**     * Launched from inetd/xinetd/systemd, or as a stand-alone server</span><br><span class="line">**     * One process per request</span><br><span class="line">**     * Deliver static content or run CGI or SCGI</span><br><span class="line">**     * Virtual sites based on the &quot;Host:&quot; property of the HTTP header</span><br><span class="line">**     * Runs in a chroot jail</span><br><span class="line">**     * Unified log file in a CSV format</span><br><span class="line">**     * Small code base (this 1 file) to facilitate security auditing</span><br><span class="line">**     * Simple setup - no configuration files to misconfigure</span><br><span class="line">** </span><br><span class="line">** This file implements a small and simple but secure and effective web</span><br><span class="line">** server.  There are no frills.  Anything that could be reasonably</span><br><span class="line">** omitted has been.</span><br><span class="line">**</span><br><span class="line">** Setup rules:</span><br><span class="line">**</span><br><span class="line">**    (1) Launch as root from inetd/systemd like this:</span><br><span class="line">**</span><br><span class="line">**            althttpd -logfile logfile -root /home/www -user nobody</span><br><span class="line">**</span><br><span class="line">**        It will automatically chroot to /home/www and become user &quot;nobody&quot;.</span><br><span class="line">**        The logfile name should be relative to the chroot jail.</span><br><span class="line">**</span><br><span class="line">**    (2) Directories of the form &quot;<span class="emphasis">*.website&quot; (ex: www_sqlite_org.website)</span></span><br><span class="line"><span class="emphasis">*</span>*        contain content.  The directory is chosen based on the HTTP<span class="emphasis">_HOST</span></span><br><span class="line"><span class="emphasis">**        request header.  If there is no HTTP_</span>HOST header or if the</span><br><span class="line">**        corresponding host directory does not exist, then the</span><br><span class="line">**        &quot;default.website&quot; is used.</span><br><span class="line">**</span><br><span class="line">**        In stand-alone mode (when the --port, --page, or --popup options are</span><br><span class="line">**        used) if neither the HTTP<span class="emphasis">_HOST.website nor &quot;default.website&quot;</span></span><br><span class="line"><span class="emphasis">**        directories exist, then files are served directly from the </span></span><br><span class="line"><span class="emphasis">**        directory from which althttpd was launched.  This makes it easy</span></span><br><span class="line"><span class="emphasis">**        to run a quick web-server for testing purposes using commands like:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**            althttpd --page fiddle.html</span></span><br><span class="line"><span class="emphasis">**            althttpd --popup</span></span><br><span class="line"><span class="emphasis">**            althttpd --port 8080..8090</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**        In one-connection mode (when launched from xinetd or similar)</span></span><br><span class="line"><span class="emphasis">**        an error is raised if &quot;default.website&quot; does not exist.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**        If the HTTP_</span>HOST header contains any charaters other than</span><br><span class="line">**        [a-zA-Z0-9<span class="emphasis">_.,*~/] then a 403 error is generated.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (3) Any file or directory whose name begins with &quot;.&quot; or &quot;-&quot; is ignored,</span></span><br><span class="line"><span class="emphasis">**        except if the URL begins with &quot;/.well-known/&quot; then initial &quot;.&quot; and</span></span><br><span class="line"><span class="emphasis">**        &quot;-&quot; characters are allowed, but not initial &quot;..&quot;.  The exception is</span></span><br><span class="line"><span class="emphasis">**        for RFC-5785 to allow letsencrypt or certbot to generate a TLS cert</span></span><br><span class="line"><span class="emphasis">**        using webroot.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (4) Characters other than [0-9a-zA-Z,-./:_</span>~] and any %HH characters</span><br><span class="line">**        escapes in the filename are all translated into &quot;<span class="emphasis">_&quot;.  This is</span></span><br><span class="line"><span class="emphasis">**        a defense against cross-site scripting attacks and other mischief.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (5) Executable files are run as CGI.  Files whose name ends with &quot;.scgi&quot;</span></span><br><span class="line"><span class="emphasis">**        trigger an SCGI request (see item 9 below).  All other files</span></span><br><span class="line"><span class="emphasis">**        are delivered as is.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (6) If a file named &quot;-auth&quot; exists in the same directory as the file to</span></span><br><span class="line"><span class="emphasis">**        be run as CGI/SCGI or to be delivered, then it contains information</span></span><br><span class="line"><span class="emphasis">**        for HTTP Basic authorization.  See file format details below.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (7) To run as a stand-alone server, simply add the &quot;-port N&quot; command-line</span></span><br><span class="line"><span class="emphasis">**        option to define which TCP port to listen on.  If the argument is</span></span><br><span class="line"><span class="emphasis">**        &quot;--port N1..N2&quot; then TCP ports between N1 and N2 are scanned looking</span></span><br><span class="line"><span class="emphasis">**        for one that is open and the first open port is used.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (8) For static content, the mimetype is determined by the file suffix</span></span><br><span class="line"><span class="emphasis">**        using a table built into the source code below.  If you have</span></span><br><span class="line"><span class="emphasis">**        unusual content files, you might need to extend this table.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    (9) Content files that end with &quot;.scgi&quot; and that contain text of the</span></span><br><span class="line"><span class="emphasis">**        form &quot;SCGI hostname port&quot; will format an SCGI request and send it</span></span><br><span class="line"><span class="emphasis">**        to hostname:port, then relay back the reply.  Error behavior is</span></span><br><span class="line"><span class="emphasis">**        determined by subsequent lines of the .scgi file.  See SCGI below</span></span><br><span class="line"><span class="emphasis">**        for details.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**   (10) If compiled with -DENABLE_</span>TLS and linked against OpenSSL and</span><br><span class="line">**        launched with a --cert option to identify a certificate file, then</span><br><span class="line">**        TLS is used to encrypt the connection.</span><br><span class="line">**</span><br><span class="line">** Command-line Options:</span><br><span class="line">**</span><br><span class="line">**  --root DIR       Defines the directory that contains the various</span><br><span class="line">**                   $HOST.website subdirectories, each containing web content </span><br><span class="line">**                   for a single virtual host.  If launched as root and if</span><br><span class="line">**                   &quot;--user USER&quot; also appears on the command-line and if</span><br><span class="line">**                   &quot;--jail 0&quot; is omitted, then the process runs in a chroot</span><br><span class="line">**                   jail rooted at this directory and under the userid USER.</span><br><span class="line">**                   This option is required for xinetd launch but defaults</span><br><span class="line">**                   to &quot;.&quot; for a stand-alone web server.</span><br><span class="line">**</span><br><span class="line">**  --port N         Run in standalone mode listening on TCP port N, or from</span><br><span class="line">**  --port N1..N2    the first available TCP port in the range from N1 to N2.</span><br><span class="line">**</span><br><span class="line">**  --user USER      Define the user under which the process should run if</span><br><span class="line">**                   originally launched as root.  This process will refuse to</span><br><span class="line">**                   run as root (for security).  If this option is omitted and</span><br><span class="line">**                   the process is launched as root, it will abort without</span><br><span class="line">**                   processing any HTTP requests.</span><br><span class="line">**</span><br><span class="line">**  --logfile FILE   Append a single-line, CSV-format, log file entry to FILE</span><br><span class="line">**                   for each HTTP request.  FILE should be a full pathname.</span><br><span class="line">**                   The FILE name is interpreted inside the chroot jail.  The</span><br><span class="line">**                   FILE name is expanded using strftime() if it contains</span><br><span class="line">**                   at least one &#x27;%&#x27; and is not too long.</span><br><span class="line">**</span><br><span class="line">**  --ipshun DIR     If the remote IP address is also the name of a file</span><br><span class="line">**                   in DIR that has size N bytes and where either N is zero</span><br><span class="line">**                   or the m-time of the file is less than N time-units ago</span><br><span class="line">**                   then that IP address is being shunned and no requests</span><br><span class="line">**                   are processed.  The time-unit is a compile-time option</span><br><span class="line">**                   (BANISH<span class="emphasis">_TIME) that defaults to 300 seconds.  If this</span></span><br><span class="line"><span class="emphasis">**                   happens, the client gets a 503 Service Unavailable</span></span><br><span class="line"><span class="emphasis">**                   reply. Furthermore, althttpd will create ip-shunning</span></span><br><span class="line"><span class="emphasis">**                   files following a 404 Not Found error if the request</span></span><br><span class="line"><span class="emphasis">**                   URI is an obvious hack attempt.  The ip-shunning file</span></span><br><span class="line"><span class="emphasis">**                   will also be created if a CGI returns status code 418.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --https BOOLEAN  Indicates that input is coming over SSL and is being</span></span><br><span class="line"><span class="emphasis">**                   decoded upstream, perhaps by stunnel. This option</span></span><br><span class="line"><span class="emphasis">**                   does *not* activate built-in TLS support.  Use --cert</span></span><br><span class="line"><span class="emphasis">**                   for that.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --page NAME      Come up in stand-alone mode, and then try to launch a</span></span><br><span class="line"><span class="emphasis">**                   web-browser pointing to the NAME document after the</span></span><br><span class="line"><span class="emphasis">**                   listening socket has been created.  This option</span></span><br><span class="line"><span class="emphasis">**                   implies --loopback and &quot;--port 8080..8100&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --popup          Launch a stand-alone web server to use for testing.</span></span><br><span class="line"><span class="emphasis">**                   This option implies &quot;--port 8080..8100&quot;.  This option</span></span><br><span class="line"><span class="emphasis">**                   is similar to &quot;--page NAME&quot; except that it does not</span></span><br><span class="line"><span class="emphasis">**                   try to launch a web-browser and does not force the</span></span><br><span class="line"><span class="emphasis">**                   connection into --loopback mode.  Use this when</span></span><br><span class="line"><span class="emphasis">**                   running a test web-server on a remote host via ssh.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --loopback       Only accept loop-back TCP connections (connections</span></span><br><span class="line"><span class="emphasis">**                   originating from the same host).  This is the</span></span><br><span class="line"><span class="emphasis">**                   default if --root is omitted.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --family ipv4    Only accept input from IPV4 or IPV6, respectively.</span></span><br><span class="line"><span class="emphasis">**  --family ipv6    These options are only meaningful if althttpd is run</span></span><br><span class="line"><span class="emphasis">**                   as a stand-alone server.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --jail BOOLEAN   Indicates whether or not to form a chroot jail if </span></span><br><span class="line"><span class="emphasis">**                   initially run as root.  The default is true, so the only</span></span><br><span class="line"><span class="emphasis">**                   useful variant of this option is &quot;--jail 0&quot; which prevents</span></span><br><span class="line"><span class="emphasis">**                   the formation of the chroot jail.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --max-age SEC    The value for &quot;Cache-Control: max-age=%d&quot;.  Defaults to</span></span><br><span class="line"><span class="emphasis">**                   120 seconds.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --max-cpu SEC    Maximum number of seconds of CPU time allowed per</span></span><br><span class="line"><span class="emphasis">**                   HTTP connection.  Default 30 (build option:</span></span><br><span class="line"><span class="emphasis">**                   -DMAX_</span>CPU=integer). 0 means no limit.</span><br><span class="line">**</span><br><span class="line">**  --debug BOOLEAN  Disables input timeouts.  This is useful for debugging</span><br><span class="line">**                   when inputs are being typed in manually.</span><br><span class="line">**</span><br><span class="line">**  --enable-sab     Add new lines to the HTTP reply header that are</span><br><span class="line">**                   prerequisites for SharedArrayBuffer.  These are the lines:</span><br><span class="line">**                     Cross-Origin-Embedder-Policy: require-corp</span><br><span class="line">**                     Cross-Origin-Opener-Policy: same-origin</span><br><span class="line">**        </span><br><span class="line">**</span><br><span class="line">** Additional command-line options available when compiling with ENABLE<span class="emphasis">_TLS:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --cert FILE      The TLS certificate, the &quot;fullchain.pem&quot; file</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**  --pkey FILE      The TLS private key, the &quot;privkey.pem&quot; file.  May be</span></span><br><span class="line"><span class="emphasis">**                   omitted if the --cert file is the concatenation of</span></span><br><span class="line"><span class="emphasis">**                   the fullchain.pem and the privkey.pem.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Command-line options can take either one or two initial &quot;-&quot; characters.</span></span><br><span class="line"><span class="emphasis">** So &quot;--debug&quot; and &quot;-debug&quot; mean the same thing, for example.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Security Features:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (1)  This program automatically puts itself inside a chroot jail if</span></span><br><span class="line"><span class="emphasis">**      it can and if not specifically prohibited by the &quot;--jail 0&quot;</span></span><br><span class="line"><span class="emphasis">**      command-line option.  The root of the jail is the directory that</span></span><br><span class="line"><span class="emphasis">**      contains the various $HOST.website content subdirectories.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (2)  No input is read while this process has root privileges.  Root</span></span><br><span class="line"><span class="emphasis">**      privileges are dropped prior to reading any input (but after entering</span></span><br><span class="line"><span class="emphasis">**      the chroot jail, of course).  If root privileges cannot be dropped</span></span><br><span class="line"><span class="emphasis">**      (for example because the --user command-line option was omitted or</span></span><br><span class="line"><span class="emphasis">**      because the user specified by the --user option does not exist), </span></span><br><span class="line"><span class="emphasis">**      then the process aborts with an error prior to reading any input.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (3)  The length of an HTTP request is limited to MAX_</span>CONTENT<span class="emphasis">_LENGTH bytes</span></span><br><span class="line"><span class="emphasis">**      (default: 250 million).  Any HTTP request longer than this fails</span></span><br><span class="line"><span class="emphasis">**      with an error. (Build option: -DMAX_</span>CONTENT<span class="emphasis">_LENGTH=integer)</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (4)  There are hard-coded time-outs on each HTTP request.  If this process</span></span><br><span class="line"><span class="emphasis">**      waits longer than the timeout for the complete request, or for CGI</span></span><br><span class="line"><span class="emphasis">**      to finish running, then this process aborts.  (The timeout feature</span></span><br><span class="line"><span class="emphasis">**      can be disabled using the --debug command-line option.)</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (5)  If the HTTP_</span>HOST request header contains characters other than</span><br><span class="line">**      [0-9a-zA-Z,-./:<span class="emphasis">_~] then the entire request is rejected.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (6)  Any characters in the URI pathname other than [0-9a-zA-Z,-./:_</span>~]</span><br><span class="line">**      are converted into &quot;<span class="emphasis">_&quot;.  This applies to the pathname only, not</span></span><br><span class="line"><span class="emphasis">**      to the query parameters or fragment.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (7)  If the first character of any URI pathname component is &quot;.&quot; or &quot;-&quot;</span></span><br><span class="line"><span class="emphasis">**      then a 404 Not Found reply is generated.  This prevents attacks</span></span><br><span class="line"><span class="emphasis">**      such as including &quot;..&quot; or &quot;.&quot; directory elements in the pathname</span></span><br><span class="line"><span class="emphasis">**      and allows placing files and directories in the content subdirectory</span></span><br><span class="line"><span class="emphasis">**      that are invisible to all HTTP requests, by making the first </span></span><br><span class="line"><span class="emphasis">**      character of the file or subdirectory name &quot;-&quot; or &quot;.&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (8)  The request URI must begin with &quot;/&quot; or else a 404 error is generated.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (9)  This program never sets the value of an environment variable to a</span></span><br><span class="line"><span class="emphasis">**      string that begins with &quot;() &#123;&quot;.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (10) If the --ipshun option is used, specific IP addresses can be</span></span><br><span class="line"><span class="emphasis">**      temporarily block for abusive behavior.  </span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** (11) If a CGI reports status code 418 (&quot;I&#x27;m a teapot&quot;, rfc2324) and if</span></span><br><span class="line"><span class="emphasis">**      the --ipshun option is used, then the IP address is temporarily</span></span><br><span class="line"><span class="emphasis">**      blocked.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Security Auditing:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** This webserver mostly only serves static content.  Any security risk will</span></span><br><span class="line"><span class="emphasis">** come from CGI and SCGI.  To check an installation for security, then, it</span></span><br><span class="line"><span class="emphasis">** makes sense to focus on the CGI and SCGI scripts.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** To locate all CGI files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          find *.website -executable -type f -print</span></span><br><span class="line"><span class="emphasis">**     OR:  find *.website -perm +0111 -type f -print</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** The first form of the &quot;find&quot; command is preferred, but is only supported</span></span><br><span class="line"><span class="emphasis">** by GNU find.  On a Mac, you&#x27;ll have to use the second form.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** To find all SCGI files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          find *.website -name &#x27;*.scgi&#x27; -type f -print</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** If any file is a security concern, it can be disabled on a live</span></span><br><span class="line"><span class="emphasis">** installation by turning off read permissions:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**          chmod 0000 file-of-concern</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** SCGI Specification Files:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Content files (files without the execute bit set) that end with &quot;.scgi&quot;</span></span><br><span class="line"><span class="emphasis">** specify a connection to an SCGI server.  The format of the .scgi file</span></span><br><span class="line"><span class="emphasis">** follows this template:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**      SCGI hostname port</span></span><br><span class="line"><span class="emphasis">**      fallback: fallback-filename</span></span><br><span class="line"><span class="emphasis">**      relight: relight-command</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** The first line specifies the location and TCP/IP port of the SCGI</span></span><br><span class="line"><span class="emphasis">** server that will handle the request.  Subsequent lines determine</span></span><br><span class="line"><span class="emphasis">** what to do if the SCGI server cannot be contacted.  If the</span></span><br><span class="line"><span class="emphasis">** &quot;relight:&quot; line is present, then the relight-command is run using</span></span><br><span class="line"><span class="emphasis">** system() and the connection is retried after a 1-second delay.  Use</span></span><br><span class="line"><span class="emphasis">** &quot;&amp;&quot; at the end of the relight-command to run it in the background.</span></span><br><span class="line"><span class="emphasis">** Make sure the relight-command does not generate output, or that</span></span><br><span class="line"><span class="emphasis">** output will become part of the SCGI reply.  Add a &quot;&gt;/dev/null&quot;</span></span><br><span class="line"><span class="emphasis">** suffix (before the &quot;&amp;&quot;) to the relight-command if necessary to</span></span><br><span class="line"><span class="emphasis">** suppress output.  If there is no relight-command, or if the relight</span></span><br><span class="line"><span class="emphasis">** is attempted but the SCGI server still cannot be contacted, then</span></span><br><span class="line"><span class="emphasis">** the content of the fallback-filename file is returned as a</span></span><br><span class="line"><span class="emphasis">** substitute for the SCGI request.  The mimetype is determined by the</span></span><br><span class="line"><span class="emphasis">** suffix on the fallback-filename.  The fallback-filename would</span></span><br><span class="line"><span class="emphasis">** typically be an error message indicating that the service is</span></span><br><span class="line"><span class="emphasis">** temporarily unavailable.</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** Basic Authorization:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">** If the file &quot;-auth&quot; exists in the same directory as the content file</span></span><br><span class="line"><span class="emphasis">** (for both static content and CGI) then it contains the information used</span></span><br><span class="line"><span class="emphasis">** for basic authorization.  The file format is as follows:</span></span><br><span class="line"><span class="emphasis">**</span></span><br><span class="line"><span class="emphasis">**    *  Blank lines and lines that begin with &#x27;#&#x27; are ignored</span></span><br><span class="line"><span class="emphasis">**    *  &quot;http-redirect&quot; forces a redirect to HTTPS if not there already</span></span><br><span class="line"><span class="emphasis">**    *  &quot;https-only&quot; disallows operation in HTTP</span></span><br><span class="line"><span class="emphasis">**    *  &quot;user NAME LOGIN:PASSWORD&quot; checks to see if LOGIN:PASSWORD </span></span><br><span class="line"><span class="emphasis">**       authorization credentials are provided, and if so sets the</span></span><br><span class="line"><span class="emphasis">**       REMOTE_</span>USER to NAME.</span><br><span class="line">**    *  &quot;realm TEXT&quot; sets the realm to TEXT.</span><br><span class="line">**</span><br><span class="line">** There can be multiple &quot;user&quot; lines.  If no &quot;user&quot; line matches, the</span><br><span class="line">** request fails with a 401 error.</span><br><span class="line">**</span><br><span class="line">** Because of security rule (7), there is no way for the content of the &quot;-auth&quot;</span><br><span class="line">** file to leak out via HTTP request.</span><br><span class="line"><span class="emphasis">*/</span></span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>作者代码开篇介绍的是该项目的功能：</p><p> 1.可以通过<strong>inetd</strong>、<strong>xinetd</strong>或<strong>systemd</strong>启动，也可以作为一个独立的服务器启动。</p><p> 2.每个请求都有一个独立的进程来处理：每个客户端请求都有一个独立进程来处理，隔离了不同的请求，保证安全性</p><p> 3.可以提供静态文件内容，也可以运行CGI或SCGI脚本，来生成动态内容</p><p> 4.支持HTTP请求中头中“Host”虚拟主机的标示，可以为不同的主机名提供不同的内容，意味着多个域名可以共享一个主机</p><p> 5.服务器运行在<strong>chroot</strong>环境中，意味着被限制在一个特定的目录中，增加了安全性</p><p> 6.服务器生成统一的日志文件，<strong>CSV</strong>格式文件</p><p> 7.服务器代码非常小，仅仅由一个文件组成，对代码进行评审会非常容易</p><p> 8.配置简单，没有复杂的配置文件来配置，降低了配置错误的可能性，服务器也方便维护。</p><h3 id="Althttp设置规则"><a href="#Althttp设置规则" class="headerlink" title="Althttp设置规则"></a>Althttp设置规则</h3><p>1.可以作为 <code>root</code> 用户从 <strong>inetd</strong> 或 <strong>systemd</strong> 启动。通过命令行参数指定日志文件 <strong>-logfile</strong>，根目录 <strong>-root</strong>，和用户 <strong>-user</strong>。服务器将自动在 <strong>-root</strong> 目录下进行 <strong>chroot</strong> 操作，并切换到指定的用户（在这个例子中是 “<strong>nobody</strong>“ 用户）。日志文件的名称应该是相对于 chroot 环境的路径。</p><p>2.目录名称以 “*.website” 格式表示（例如：www_sqlite_org.website），包含网站内容。服务器将根据 HTTP 请求头中的 “Host:” 属性选择对应的目录。如果没有 HTTP 请求头中的 “Host:” 属性，或者对应的主机目录不存在，那么将使用 “default.website” 目录。在独立模式下，如果既没有 HTTP_HOST.website 目录，也没有 “default.website” 目录，则直接从启动 althttpd 的目录中提供文件。这使得可以轻松地用于测试目的。</p><p>3.文件或目录名称以 “.” 或 “-“ 开头的将被忽略，但如果 URL 以 “&#x2F;.well-known&#x2F;“ 开头，则允许初始的 “.” 和 “-“ 字符，但不允许初始的 “..”。这是为了允许 <strong>RFC-5785</strong> 支持，以便 <strong>letsencrypt</strong> 或 <strong>certbot</strong> 可以使用 webroot 生成 TLS 证书。</p><p>4.文件名中除了 [0-9a-zA-Z,-.&#x2F;:~] 和 %HH 字符转义之外的所有字符都被翻译为下划线。这是为了防止跨站脚本攻击等安全问题。</p><p>5.可执行文件将作为 CGI 运行。文件名以 “<strong>.scgi</strong>“ 结尾的触发 <strong>SCGI</strong> 请求，其他文件直接传递。</p><p>6.如果在与要作为 <strong>CGI&#x2F;SCGI</strong> 运行或传递的文件相同的目录中存在一个名为 “<strong>-auth</strong>“ 的文件，则它包含了 HTTP 基本认证的信息。文件格式的详细信息在下文中提供。</p><p>7.要以独立服务器运行，只需添加 “<strong>-port N</strong>“ 命令行选项，以定义要监听的 TCP 端口。如果参数是 “<strong>–port N1..N2</strong>“，则将扫描介于 N1 和 N2 之间的 TCP 端口，找到第一个空闲的端口并使用它。</p><p>8.对于静态内容，服务器通过文件后缀来确定 <strong>MIME</strong> 类型，使用内置在源代码中的表。如果有不常见的内容文件，可能需要扩展此表。</p><p>9.以 “<strong>.scgi</strong>“ 结尾的内容文件，如果包含 “<strong>SCGI hostname port</strong>“格式的文本，将格式化 <strong>SCGI</strong> 请求并发送到 <strong>hostname:port</strong>，然后中继回复。错误行为由”<strong>.scgi</strong>“文件的后续行确定。</p><p>10.如果使用<code>-DENABLE_TLS</code>编译选项并链接到 OpenSSL，并使用 <code>--cert</code> 选项启动以指定证书文件，则将使用 <code>TLS</code> 加密连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode】2.两数相加-C</title>
      <link href="/2023/09/11/2023-8-20-13-01-19-c-leetcode2/"/>
      <url>/2023/09/11/2023-8-20-13-01-19-c-leetcode2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p><strong>题目</strong> ：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg"></p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</p><p>输出：[7,0,8]</p><p>解释：342 + 465 &#x3D; 807.</p><p><strong>示例 2：</strong></p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]</p><p>输出：[0]</p><p><strong>示例 3：</strong></p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</p><p>输出：[8,9,9,9,0,0,0,1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span>&#123;</span><br><span class="line">    <span class="comment">//创建head和tail指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span>=</span><span class="literal">NULL</span>,*tail=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//记录两个值相加的进位</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(l1 || l2)&#123;    <span class="comment">//l1,l2不都为空</span></span><br><span class="line">        <span class="type">int</span> n1 = l1?l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n2 = l2?l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = n1 + n2 + count;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="comment">//节点为空,头和尾同时置一下</span></span><br><span class="line">            head = tail = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail-&gt;val = sum % <span class="number">10</span>;   <span class="comment">//取余数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已经有头节点，尾节点的下一个开辟空间</span></span><br><span class="line">            tail-&gt;next = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;val = sum % <span class="number">10</span>;  <span class="comment">//取余数</span></span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        count = sum / <span class="number">10</span>;   <span class="comment">//count取进位</span></span><br><span class="line">        <span class="comment">//l1和l2两个链表向后移动</span></span><br><span class="line">        <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count != <span class="number">0</span>)  <span class="comment">//count不为0，最后一个节点有进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        tail-&gt;val = count;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/note/note8.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】5. 最长回文子串-C</title>
      <link href="/2023/09/10/2023-9-10-16-3A22-3A58-c-leetcode5/"/>
      <url>/2023/09/10/2023-9-10-16-3A22-3A58-c-leetcode5/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><hr><p><strong>示例 1：</strong></p><p><strong>输入：</strong><br>s &#x3D; “babad”</p><p><strong>输出：</strong>“bab”</p><p><strong>解释：</strong>“aba” 同样是符合题意的答案。</p><hr><p><strong>示例 2：</strong></p><p><strong>输入：</strong><br>s &#x3D; “cbbd”</p><p><strong>输出：</strong>“bb”</p><hr><hr><p><strong>提示：</strong></p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</p><p>s 仅由数字和英文字母组成</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">longestPalindrome</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】4.寻找两个正序数组的中位数-C</title>
      <link href="/2023/09/05/2023-9-05-12-11-16-c-leetcode4/"/>
      <url>/2023/09/05/2023-9-05-12-11-16-c-leetcode4/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h1><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><h2 id="算法的时间复杂度应该为-O-log-m-n-。"><a href="#算法的时间复杂度应该为-O-log-m-n-。" class="headerlink" title="算法的时间复杂度应该为 O(log (m+n)) 。"></a>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</h2><p><code>示例 1：</code></p><p><strong>输入：</strong>nums1 &#x3D; [1,3], nums2 &#x3D; [2]</p><p><strong>输出：</strong>2.00000</p><p><strong>解释：</strong>合并数组 &#x3D; [1,2,3] ，中位数 2</p><hr><hr><p><code>示例 2：</code></p><p><strong>输入：</strong>nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</p><p><strong>输出：</strong>2.50000</p><p><strong>解释：</strong>合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><hr><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>两个数组是正序排序的，可以将两个数组合并到一个数组里，然后判断数组长度是不是<code>2</code>的倍数，如果是<strong>取中间两个数之和除以2</strong>，不是的话<strong>直接取中间数</strong>进行返回就行了。</p><p>所以这么写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *n = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(nums1Size+nums2Size));</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums1Size &amp;&amp; j&lt;nums2Size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两个数组都有数据,依照正序存到n数组中</span></span><br><span class="line">        n[nSize++] = nums1[i]&lt;nums2[j]?nums1[i++]:nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums1Size)  <span class="comment">//num1还有数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        n[nSize++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums2Size)  <span class="comment">//num2还有数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        n[nSize++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nSize%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//判断长度奇偶</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//偶数取中间两数之和/2</span></span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">float</span>)n[nSize<span class="number">-1</span>]+(<span class="type">float</span>)n[nSize])/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//奇数直接取中间值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(n[nSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】3.无重复字符的最长子串-C</title>
      <link href="/2023/08/28/2023-8-28-12-15-20-c-leetcode3/"/>
      <url>/2023/08/28/2023-8-28-12-15-20-c-leetcode3/</url>
      
        <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a><strong>示例1：</strong></h2><p><strong>输入:</strong> s &#x3D; “abcabcbb”</p><p><strong>输出:</strong> 3 </p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><hr><h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a><strong>示例2：</strong></h2><p><strong>输入:</strong> s &#x3D; “bbbbb”</p><p><strong>输出:</strong> 1</p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><hr><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a><strong>示例3：</strong></h2><p><strong>输入:</strong> s &#x3D; “pwwkew”</p><p><strong>输出:</strong> 3</p><p><strong>解释:</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><hr><p><strong>提示：</strong></p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</p><p>s 由英文字母、数字、符号和空格组成</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>这个题抓住最主要的就能通透理解了，<strong>s 是由字符串组成</strong>，说明不管s的长度有多长，他都是ascii码组成，ascii码总共有<strong>127</strong>个，所以他最大无重复字符串长度也就最多是127个。</p><p>我们只需要使用一个128空间长度的表来存这些ascii码就足够了。</p><p>使用<strong>滑动窗口</strong>的方法，用到左指针和右指针，右指针专门来遍历<code>s</code>字符串，左指针来控制我们的<code>map</code>，也就是我们自己的一个数据表。</p><p><code>思路</code>是：右指针不停的向右遍历<code>s</code>字符串，当我们发现<code>map</code>表中没有这个元素，我们就<strong>存进去</strong>，如果发现<code>右指针</code>的元素在当前的表中<strong>存在</strong>，那我们将<code>左指针</code>一直向右移动，直到<code>左指针</code>跑到和当前元素相等的位置，在此基础上，把<strong>map表</strong>左指针遍历过的<code>值</code>全部移除(包括相等的那个值)，这样，我们的<code>map表长度</code>不会超过最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>1.定义一个map表描述</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MAX_LENGTH  128</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAP_MAX_LENGTH];</span><br><span class="line">    <span class="type">__uint8_t</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.判断map表中是否有无相等元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断表中是否右相等元素数据</span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-不存在，1-存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">isExtData</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">map</span>-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">__uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="built_in">map</span>-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>-&gt;data[i]==ch)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.向map表中插入数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向map表插入数据</span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-成功，1-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">insertDataToMap</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断表中有无数据</span></span><br><span class="line">    <span class="keyword">if</span>(isExtData(<span class="built_in">map</span>,ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//存在数据直接返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>-&gt;data[<span class="built_in">map</span>-&gt;length++] = ch;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//存进表中返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.从map表中移除数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从map表中移除数据 </span></span><br><span class="line"><span class="comment"> * @param map 表</span></span><br><span class="line"><span class="comment"> * @param ch 元素</span></span><br><span class="line"><span class="comment"> * @return 0-成功，1-失败(其实无所谓了这里)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">__uint8_t</span> <span class="title function_">removeDataFromMap</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">map</span> *<span class="built_in">map</span>,<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isExtData(<span class="built_in">map</span>,ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">__uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="built_in">map</span>-&gt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>-&gt;data[i]==ch)<span class="comment">//找到元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">__uint8_t</span> j=i;j&lt;<span class="built_in">map</span>-&gt;length<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>-&gt;data[j]=<span class="built_in">map</span>-&gt;data[j+<span class="number">1</span>];<span class="comment">//把数据向前搬移一位</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>-&gt;length-=<span class="number">1</span>;<span class="comment">//同时让表长度-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.获取最长字串的长度</strong></p><p>结合上边我们的三个辅助函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="comment">//创建表，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> <span class="title">map</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">map</span>.data,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>.data));</span><br><span class="line">    <span class="built_in">map</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义左右指针，记录当前长度length和最大长度maxLength</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,length=<span class="number">0</span>,maxLength=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//窗口的右指针为边界</span></span><br><span class="line">    <span class="keyword">while</span>(right&lt;<span class="built_in">strlen</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断右指针的值是否在map中，如果不存在，将元素添加到map中，然后length+1，右指针向右移动，</span></span><br><span class="line">        <span class="comment">//然后用maxlength记录最大的length值</span></span><br><span class="line">        <span class="keyword">if</span>(isExtData(&amp;<span class="built_in">map</span>,s[right]))</span><br><span class="line">        &#123;</span><br><span class="line">           insertDataToMap(&amp;<span class="built_in">map</span>,s[right]);</span><br><span class="line">           length+=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(length &gt; maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">           &#125;</span><br><span class="line">           right+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右指针元素在map中存在，说明滑动区间存在两个相同的元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当右指针元素的值存在map时，我们移除map中左指针的值，然后将左指针向右移动一个单位，length相应的要减一</span></span><br><span class="line">            <span class="keyword">while</span>(!isExtData(&amp;<span class="built_in">map</span>,s[right]))&#123;</span><br><span class="line">                removeDataFromMap(&amp;<span class="built_in">map</span>,s[left]);</span><br><span class="line">                left+=<span class="number">1</span>;</span><br><span class="line">                length-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上述while结束或者map中不存在左指针值，说明map中又是无重复的元素，那我们继续添加右指针值，</span></span><br><span class="line">            <span class="comment">//然后长度加一，右指针继续向右移动，</span></span><br><span class="line">            insertDataToMap(&amp;<span class="built_in">map</span>,s[right]);</span><br><span class="line">            length+=<span class="number">1</span>;</span><br><span class="line">            right+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode每日一题】2236-判断很节点是否等于子节点之和</title>
      <link href="/2023/08/20/2023-8-20-21-56-50-leetcode2236/"/>
      <url>/2023/08/20/2023-8-20-21-56-50-leetcode2236/</url>
      
        <content type="html"><![CDATA[<h1 id="2236-判断很节点是否等于子节点之和"><a href="#2236-判断很节点是否等于子节点之和" class="headerlink" title="2236-判断很节点是否等于子节点之和"></a>2236-判断很节点是否等于子节点之和</h1><p>给你一个 <strong>二叉树</strong> 的根结点 <code>root</code>，该二叉树由恰好 3 个结点组成：<code>根结点</code>、<code>左子结点</code>和<code>右子结点</code>。</p><p>如果根结点值等于两个子结点值之和，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png"></p><hr><p>输入：root &#x3D; [10,4,6]</p><p>输出：true</p><p>解释：根结点、左子结点和右子结点的值分别是 10 、4 和 6 。<br>由于 10 等于 4 + 6 ，因此返回 true 。</p><hr><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png"></p><hr><p>输入：root &#x3D; [5,3,1]</p><p>输出：false</p><p>解释：根结点、左子结点和右子结点的值分别是 5 、3 和 1 。由于 5 不等于 3 + 1 ，因此返回 false</p><hr><hr><p><strong>提示：</strong></p><p>树只包含根结点、左子结点和右子结点</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><hr><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>这题没有难度，直接就是一个判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">checkTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root-&gt;val == (root-&gt;left-&gt;val+root-&gt;right-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/note/note7.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【c语言数据结构】</title>
      <link href="/2023/08/12/2023-8-12-17-12-25-list-arr/"/>
      <url>/2023/08/12/2023-8-12-17-12-25-list-arr/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言数据结构"><a href="#c语言数据结构" class="headerlink" title="c语言数据结构"></a>c语言数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放数据的一串连续的空间，它的声明是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果你不想定义空间长度可以这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>这样如果在后续运算的过程中我们要用到它的长度，你可以这样</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr_len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>它的意思就是整个,<strong>整个数组空间大小&#x2F;数组单个空间大小</strong>，得到我们的数组长度。可以将它定义为<code>宏</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_SIZE(x)(sizeof(x)/sizeof(x[0]))</span></span><br></pre></td></tr></table></figure><p>这样在写代码过程中直接调用<code>ARR_SIZE</code>，向里边传递数组就可以得到数组长度。</p><p>数组在空间上是连续的，我们可以通过下标来获取指定位置的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_SIZE(x)(sizeof(x)/sizeof(x[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="type">int</span> a3 = arr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下标从<code>0</code>开始。所以我们<code>a3</code>得到的值是<strong>arr</strong>数组第三个值<code>3</code>。</p><p>优点：从数组中获取数据，它的时间复杂度是<code>O(1)</code>，是最快的。</p><p>缺点：数据空间长度必须明确，以防止我们存储或者获取数据时不会出现越界。</p><p><strong>以上按照顺序表来举例</strong></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><code>顺序表</code>就是由数组来构成的，就像名称一样，它的数据排布是按顺序来构成的，中间也尽量不留空。但是有一个缺点，<strong>顺序表的长度是需要提前设定好的，这可以根据我们要安排存储的数据大小来提前设定好顺序表长度</strong></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>链表就是通过指针来将多个数据绑定到一块，他们在内存上分布一般是不会连续的，所以通过<code>指针</code>来将这些数据串联起来。</p><p>组成：将数据整理成节点，然后这些节点通过指针连接起来，最后只需要一个头节点的地址，我们就能访问整个链表所有的节点数据。</p><p>例子：创建一个节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br></pre></td></tr></table></figure><p>以上就是一个链表节点的例子，但是通常情况下，我个人不习惯这样用，因为<strong>我们既然都用链表了，如果这个链表提供给我们的信息太少，那对于链表的节点的查找和存储相比较更麻烦，比如说你不记录这个链表的长度，你怎么知道这个链表到底有没有节点。链表内部的节点到底有多少。</strong>所以我个人一般这样制作一个链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br></pre></td></tr></table></figure><p>在链表节点外再套一层框架，能够记录当前链表的一些信息，比如长度，或者链表的可用性<code>加锁</code>之类的。</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">t_list <span class="built_in">list</span>;<span class="comment">//定义链表变量</span></span><br><span class="line">    <span class="built_in">list</span>.listSize = <span class="number">0</span>;<span class="comment">//节点数为0</span></span><br><span class="line">    <span class="built_in">list</span>.node = <span class="literal">NULL</span>;<span class="comment">//第一个节点不存在，为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建节点并添加data数据"><a href="#创建节点并添加data数据" class="headerlink" title="创建节点并添加data数据"></a>创建节点并添加data数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line">t_list_node *<span class="title function_">addDataToNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请一块节点大小的内存</span></span><br><span class="line">    t_list_node *node = (t_list_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(t_list_node));</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建节点失败，内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点创建完毕而且数据存储的为data</p><h3 id="向链表加入节点-尾插（尾插会了头插你也会了）"><a href="#向链表加入节点-尾插（尾插会了头插你也会了）" class="headerlink" title="向链表加入节点(尾插（尾插会了头插你也会了）)"></a>向链表加入节点(尾插（尾插会了头插你也会了）)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 把节点插入链表(尾插法)</span></span><br><span class="line"><span class="comment"> * @param list 插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 插入的节点</span></span><br><span class="line"><span class="comment"> * @return 返回链表当前长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listAddNode</span><span class="params">(t_list *<span class="built_in">list</span>,t_list_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">list</span> || !node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;<span class="comment">//用pList来控制list</span></span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="comment">//可以先进行链表长度的判断</span></span><br><span class="line">    <span class="keyword">if</span>(pList-&gt;listSize == <span class="number">0</span>)<span class="comment">//不存在节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pList-&gt;node = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(;pNode-&gt;next != <span class="literal">NULL</span>;pNode = pNode-&gt;next);</span><br><span class="line">        pNode-&gt;next = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表插入就结束了。</p><h3 id="删除链表中某个节点，删除数据为data的节点-假设链表只有一个该data节点"><a href="#删除链表中某个节点，删除数据为data的节点-假设链表只有一个该data节点" class="headerlink" title="删除链表中某个节点，删除数据为data的节点(假设链表只有一个该data节点)"></a>删除链表中某个节点，删除数据为data的节点(假设链表只有一个该data节点)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span><span class="comment">//下一个节点的指针</span></span><br><span class="line">&#125;t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> listSize;<span class="comment">//当前链表长度</span></span><br><span class="line">    ···;<span class="comment">//可以定义一些链表信息</span></span><br><span class="line">t_list_node *node;<span class="comment">//链表的第一个节点</span></span><br><span class="line">&#125;t_list;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteDataNodeFromList</span><span class="params">(t_list *<span class="built_in">list</span>, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;</span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空,删除失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">1</span>) <span class="comment">// 节点只有一个，判断是不是data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data != data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pNode);</span><br><span class="line">            pNode = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *pDele = <span class="literal">NULL</span>;<span class="comment">//定义一个删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//走到这里表示链表长度大于0，并且第一个节点就是要删除的</span></span><br><span class="line">        pDele = pNode;<span class="comment">//删除节点指向第一个节点</span></span><br><span class="line">        pNode = pNode-&gt;next; <span class="comment">//把第二个节点换成第一个节点</span></span><br><span class="line">        pList-&gt;node = pNode;<span class="comment">//重新给链表指向第一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(pDele);<span class="comment">//释放这个删除节点</span></span><br><span class="line">        pDele = <span class="literal">NULL</span>;<span class="comment">//指针置空</span></span><br><span class="line">        pList-&gt;listSize -= <span class="number">1</span>;<span class="comment">//长度-1</span></span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;<span class="comment">//返回长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//第一个不是data的节点</span></span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pNode的下一个节点不是空,进入循环</span></span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;next-&gt;data == data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//发现下一个节点的数据域为data，我们要删除的节点为下一个节点</span></span><br><span class="line">                pDele = pNode-&gt;next;<span class="comment">//删除节点指向下一个节点</span></span><br><span class="line">                pNode-&gt;next = pDele-&gt;next;<span class="comment">//将下一个节点的下一个过继到当前节点的下一个</span></span><br><span class="line">                <span class="built_in">free</span>(pDele);<span class="comment">//释放删除节点</span></span><br><span class="line">                pDele = <span class="literal">NULL</span>;<span class="comment">//置空</span></span><br><span class="line">                pList-&gt;listSize -= <span class="number">1</span>;<span class="comment">//长度-1</span></span><br><span class="line">                <span class="keyword">return</span> pList-&gt;listSize;<span class="comment">//返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个数据域不为data,pNode后移</span></span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后返回链表长度</span></span><br><span class="line">    <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除节点就做到这里</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="comment">// 创建一个节点，需要我们自己定义一个结构体类型，存储我们要放入的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 存放的数据.目前用一个int变量当作例子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t_list_node</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个节点的指针</span></span><br><span class="line">&#125; t_list_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> listSize;      <span class="comment">// 当前链表长度</span></span><br><span class="line">    t_list_node *node; <span class="comment">// 链表的第一个节点</span></span><br><span class="line">&#125; t_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建节点并存储data</span></span><br><span class="line"><span class="comment"> * @param data 存储数据</span></span><br><span class="line"><span class="comment"> * @return 返回节点地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t_list_node *<span class="title function_">addDataToNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 申请一块节点大小的内存</span></span><br><span class="line">    t_list_node *node = (t_list_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(t_list_node));</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建节点失败，内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 把节点插入链表(尾插法)</span></span><br><span class="line"><span class="comment"> * @param list 插入的链表</span></span><br><span class="line"><span class="comment"> * @param node 插入的节点</span></span><br><span class="line"><span class="comment"> * @return 返回链表当前长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listAddNode</span><span class="params">(t_list *<span class="built_in">list</span>, t_list_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list</span> || !node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>; <span class="comment">// 用pList来控制list</span></span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="comment">// 可以先进行链表长度的判断</span></span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>) <span class="comment">// 不存在节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pList-&gt;node = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (; pNode-&gt;next != <span class="literal">NULL</span>; pNode = pNode-&gt;next)</span><br><span class="line">            ;</span><br><span class="line">        pNode-&gt;next = node;</span><br><span class="line">        pList-&gt;listSize += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteDataNodeFromList</span><span class="params">(t_list *<span class="built_in">list</span>, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    t_list *pList = <span class="built_in">list</span>;</span><br><span class="line">    t_list_node *pNode = pList-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空,删除失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pList-&gt;listSize == <span class="number">1</span>) <span class="comment">// 节点只有一个，判断是不是data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data != data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pNode);</span><br><span class="line">            pNode = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;node = <span class="literal">NULL</span>;</span><br><span class="line">            pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *pDele = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;data == data)</span><br><span class="line">    &#123;</span><br><span class="line">        pDele = pNode;</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">        pList-&gt;node = pNode;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(pDele);</span><br><span class="line">        pDele = <span class="literal">NULL</span>;</span><br><span class="line">        pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode-&gt;next-&gt;data == data)</span><br><span class="line">            &#123;</span><br><span class="line">                pDele = pNode-&gt;next;</span><br><span class="line">                pNode-&gt;next = pDele-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(pDele);</span><br><span class="line">                pDele = <span class="literal">NULL</span>;</span><br><span class="line">                pList-&gt;listSize -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pNode = pNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pList-&gt;listSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    t_list <span class="built_in">list</span>;       <span class="comment">// 定义链表变量</span></span><br><span class="line">    <span class="built_in">list</span>.listSize = <span class="number">0</span>; <span class="comment">// 节点数为0</span></span><br><span class="line">    <span class="built_in">list</span>.node = <span class="literal">NULL</span>;  <span class="comment">// 第一个节点不存在，为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_list_node *node = addDataToNode(i);</span><br><span class="line">        listAddNode(&amp;<span class="built_in">list</span>, node);</span><br><span class="line">    &#125;</span><br><span class="line">    t_list_node *p = <span class="built_in">list</span>.node;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listsize = deleteDataNodeFromList(&amp;<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (listsize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无节点\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">list</span>.node;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码是向链表中加入了<code>1-10</code>个数字，然后打印一边结果，最后删除data为5的节点，再次执行打印结果</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>着重讲<code>链表</code>是因为链表比较锻炼思维，在编程里就是靠这些思维来实现代码，能让人更方便开发具有逻辑性的代码和功能。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表就是如图所示</p><p><img src="/pic/note/note4.jpg"></p><p><code>双向链表</code>对于单链表来说只是多了一条链路，连接当前节点的前一个节点。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种树状数据结构，每个节点最多包含两个子节点，<code>根节点</code>就是二叉树的顶部节点，是树的起点，</p><p>从起点开始向下延申，连接其他的节点。</p><p><code>叶子节点</code>，没有子节点的节点，位于树的末端。<code>子树</code>就是每个节点可以看成一个子树的根，包括它自己以及它的所有子节点，这些子树也是二叉树。</p><p><code>二叉树的遍历</code>：分为前序、中序、后序遍历。不同的遍历方式节点的顺序不同。</p><h3 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树节点创建"><a href="#二叉树节点创建" class="headerlink" title="二叉树节点创建"></a>二叉树节点创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">newNode</span> =</span> (<span class="keyword">struct</span> TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点插入二叉树"><a href="#节点插入二叉树" class="headerlink" title="节点插入二叉树"></a>节点插入二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode *<span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> TreeNode *root,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> createNode(data);</span><br><span class="line">    <span class="keyword">if</span>(data &lt; root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = Insert(root-&gt;left,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = Insert(root-&gt;right,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p><code>前序遍历</code>就是先访问跟节点，然后开始向下访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preorderTree</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,root-&gt;data);</span><br><span class="line">        preorderTree(root-&gt;left);</span><br><span class="line">        preorderTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><code>中序遍历</code>就是先访问二叉树的左节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorderTree(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">        inorderTree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><code>略略略</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】1.两数之和-C</title>
      <link href="/2023/08/12/2023-8-12-16-30-31-c-leetcode/"/>
      <url>/2023/08/12/2023-8-12-16-30-31-c-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><h2 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><p> 按照我们正常思路来说，两次<code>for</code>循环来判断里边的相加数</p><p>在我们自己的ubuntu上进行测试，需要我们将leetcode中的缺少的<code>main</code>函数补充完整，依次来验证我们的正确性。</p><p>leetCode中给我们提供了函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 寻找数组中相加的两数之和等于我们传入的目标数</span></span><br><span class="line"><span class="comment"> * @params nums 传入的数组</span></span><br><span class="line"><span class="comment"> * @params numsSize 传入的数组长度</span></span><br><span class="line"><span class="comment"> * @params target 目标数</span></span><br><span class="line"><span class="comment"> * @params returnSize 最后得到数组的长度</span></span><br><span class="line"><span class="comment"> * return 返回得到的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>;</span><br></pre></td></tr></table></figure><p>要注意返回值是<code>int *</code>，指针类型，也就是我们的最后存储的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>;</span><br><span class="line"><span class="comment">/* 先补充下leetcode中需要的main函数，如果你实在leetcode答题界面，以下不需要写 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//以leetcode给我们的第一个例子来演示</span></span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numsSize = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> returnSize;</span><br><span class="line">    <span class="comment">//以上全部是需要传入函数的参数</span></span><br><span class="line">    <span class="type">int</span> *getTwoNums = <span class="literal">NULL</span>;<span class="comment">//最后得到的数组指针</span></span><br><span class="line">    getTwoNums = twoSum(nums,numsSize,target,&amp;returnSize);</span><br><span class="line">    <span class="comment">//尽管这种情况在leetcode测试代码中不会出现，但是我们最好还是对得到的数组合法性进行一个判断</span></span><br><span class="line">    <span class="keyword">if</span>(getTwoNums == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getTwoNums is null\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//函数结束，下边不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;returnSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getTwoNums[%d] = %d\n&quot;</span>,i,getTwoNums[i]);<span class="comment">//打印查看我们得到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是我们补充的leetcode中缺少的main部分，可用来我们在本地进行一个测试，查看执行的效果。</p><p>接下来编写最主要的函数处理，也就是力扣中要我们添加进去的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line"><span class="comment">//因为返回值是指针，我们需要为存储我们两个变量的数组申请一块内存，以防止此函数结束时编译器不会给我们回收掉</span></span><br><span class="line">    <span class="type">int</span> *returnNums = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//按照我们正常思路，两层for循环来遍历查找里边相加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>; a&lt;numsSize<span class="number">-1</span>; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=a+<span class="number">1</span> ;b&lt;numsSize; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[a]+nums[b])==target)</span><br><span class="line">            &#123;</span><br><span class="line">                returnNums[(*returnSize)++] = a;</span><br><span class="line">                returnNums[(*returnSize)++] = b;</span><br><span class="line">                <span class="keyword">return</span> returnNums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就搞定了，<code>returnNums</code>数组中存储了我们得到的两个数的下标。不过它的时间复杂度为O(n^2)，是一种最普通的解法。</p><p>编译我们的程序，<code>gcc 1.TwoAdd.c</code>,得到<code>a.out</code>。最后执行我们的程序<code>./a.out</code>，可以看到打印结果为</p><p><code>[0,1]</code>，正好是我们得到的两个数的数组下标</p><p><img src="/pic/note/note3.jpg"></p><p>讲代码提交到leetcode，可以查看时间消耗与空间占用</p><p><img src="/pic/note/note5.jpg"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>以上方法是最常用的方法：<code>暴力破解</code>，两层for循环嵌套，时间复杂度为<code>O(n^2)</code>，但是目前我们的计算机存储可以完全不考虑空间占用，所以，目前牺牲空间来提高时间效率是现在经常使用的。为此，我们需要降低时间复杂度，降到<code>n^2</code>以下</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种数据结构，它是通过<code>键值对</code>的映射来存储数据，只要映射方式能够满足我们的需求就可以，哈希表的查找时间复杂度一般情况速度挺快的。</p><p>使用c语言中扩展库<code>uthash.h</code>来实现简单的哈希表</p><p>关于uthash.h库，可以到仓库查看。(<a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a>)</p><p>我已经提前讲源代码放入到linux的lib库中了，接下来使用它。</p><p><code>uthash.h</code>中提供了基础的哈希表。所以我们只需要自己准备好要映射的结构</p><p>对于<code>两数之和</code>来说，所有数据都是整型数，所以，键值对就设定为整型数就行</p><p><strong>UT_hash_handle</strong>是uthash库中提供的，可以链接到哈希表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span>  <span class="comment">//创建自己的键值对</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;  <span class="comment">//uthash的特殊字段，用于讲该结构链接到哈希表中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建一个指针，用于表示哈希表本身"><a href="#创建一个指针，用于表示哈希表本身" class="headerlink" title="创建一个指针，用于表示哈希表本身"></a>创建一个指针，用于表示哈希表本身</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">hashtable</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hashTable* <span class="title function_">find_val</span><span class="params">(<span class="type">int</span> ikey)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HASH_FIND_INT</strong>是uthash中提供的查找整数的宏,与此相似的还有<strong>HASH_FIND_PTR</strong>、<strong>HASH_FIND_STR</strong>等等。</p><p><code>find_val</code>用于查找哈希表中存在的键值对ikey的元素，如果找到了返回该元素的指针，找不到就返回NULL；</p><h3 id="哈希表的插入"><a href="#哈希表的插入" class="headerlink" title="哈希表的插入"></a>哈希表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ikey, <span class="type">int</span> ival)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find_val(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code>函数用于向哈希表中插入元素或者更新已有的元素，首先，通过<code>find_val</code>来查找表中是否有ikey的元素，如果没有就<code>malloc</code>创建一个元素，然后通过<code>HASH_ADD_INT</code>将该元素的键值对存储到哈希表中，如果有ikey的元素，就更新元素的值val。</p><h2 id="哈希表的两数之和解法"><a href="#哈希表的两数之和解法" class="headerlink" title="哈希表的两数之和解法"></a>哈希表的两数之和解法</h2><p>以上是简单介绍uthash库的哈希中使用到的，接下来处理解决leetcode第一题：两数之和。</p><p>我们的思路是：<strong>遍历数组，同时判断target-nums[i]的值存不存在于我们的哈希表中，如果不存在，将该nums[i]和i当作一个哈希元素存储到我们的哈希表中，这样，在我们继续向下遍历的时候，继续判断哈希表中有无(target-nums[i])这个元素，如果有就直接取对应的i</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span>  <span class="comment">//创建自己的键值对</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;  <span class="comment">//uthash的特殊字段，用于讲该结构链接到哈希表中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">hashtable</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hashTable* <span class="title function_">find_val</span><span class="params">(<span class="type">int</span> ikey)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ikey, <span class="type">int</span> ival)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> =</span> find_val(ikey);</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解题</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">numsAdd</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span> *returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//1.先将哈希表清空</span></span><br><span class="line">   hashtable = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//创建哈希元素来查找哈希表中是否存在(target-nums[i])的元素。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> *<span class="title">it</span> =</span> find_val(target-nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//存在的情况</span></span><br><span class="line">            <span class="type">int</span> *ret = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val;</span><br><span class="line">            ret[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在，将该nums[i]和i插入到我们的哈希表中</span></span><br><span class="line">        insert(nums[i],i);<span class="comment">//注意，对应上我们的结构体,第一个参数是key,第一个参数是value,我们在上边要取得是value的元素。</span></span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历到最后也没找到合适的两数之和的元素。</span></span><br><span class="line">   *returnSize = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历一边数组的方式将原本的<code>O(n^2)</code>的时间复杂度压缩到了<code>O(n)</code>。</p><p>把代码提交到leetcode看下结果</p><p><img src="/pic/note/note6.jpg"></p><p>速度快多了相比之前的76ms。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>守住你的瓦尔登湖</title>
      <link href="/2023/08/11/2023-8-11-23-59-46-Forth/"/>
      <url>/2023/08/11/2023-8-11-23-59-46-Forth/</url>
      
        <content type="html"><![CDATA[<h1 id="守住你的瓦尔登湖"><a href="#守住你的瓦尔登湖" class="headerlink" title="守住你的瓦尔登湖"></a>守住你的瓦尔登湖</h1><p><code>杨 虎</code><br>1949年,梭罗和他的湖首次来到了中国。译者徐迟在序言中这样说道:“你能把你的心安静下来吗?如果你的心并没有安静下来,我说,你也许最好是先把你的心安静下来,然后你再打开这本书,否则你也许会读不下去,认为它太浓缩,难读,艰深,甚至会觉得它莫名其妙,不知所云。”那时正值天翻地覆,安静的梭罗不知能走进多少人的内心?<br>中国内地的读者再次看到大洋彼岸这个“怪人”的身影已是33年后的1982年了。但这一次,席卷古老大陆的文学热潮即将汹涌起马尔克斯的魔方、乔伊斯的呓语,而狂热的读者们则兴奋地从小说中检索着改革、承包等字眼,为物质时代正义凛然地登场暗暗兴奋不已。<br>又一次,梭罗和他的瓦尔登湖被时代的喧嚣所淹没。<br>其实,这本书本来就是为人类中那些安静的内心写的,小众化正该是它的命运。这本诞生在湖边的书,或许是大自然最美的精灵之一,湖泊为寻找芸芸众生中和她质地一样的心湖而假手梭罗发出的信号。<br>共鸣,从来只发生在知己之间。<br>水是大地的灵者,是人生的天籁表达。如果河流象征着人生奔突冲撞的青年时代,海洋则像是童年和老年的重叠,而湖泊这大地上晶亮的眼睛,则是人生静穆平和信念坚定的中年。我不知道梭罗是怎么下决心要为人类写这一本宁静的中年之书的。或许,是瓦尔登湖翻卷的浪花突然击中了他的灵魂;或许,这一需求潜伏已久,也许更早以前,他在某个喧闹的时刻突然听到了自己内心的低语,就像叶芝在伦敦的街头忽然热泪盈眶:“我就要动身走了,去茵纳斯弗利岛;我就要动身走了,因为我听到,那水声日日夜夜轻拍着湖滨;不管我站在车行道,还是人行道,我都在心灵深处听见这声音。”<br>这样的向往,也许也曾多次在你我的内心翻涌,只是,我们不愿像梭罗那样去正视一个真实的自己,不敢像他那样舍弃世俗的一切去寻找和守住自己的瓦尔登湖。<br>人类中那些柔软与敏感的心灵总是代替凡夫俗子去感受天籁,并九死不悔地承担由此落在自己命运中的狂喜与极苦。梵高如是,高更如是,梭罗也如是。但这一次,是人类与大自然最美丽的邂逅——1844年一个落叶纷飞的秋日,27岁的亨利·戴维·梭罗只影单身,仅带着一柄斧头和二十五美元二十一美分,住进了杳无人迹的瓦尔登湖边的山林中。在此之前,他已给爱默生当了两年助手。再往前,他亲眼目睹了恋人的他嫁和相依为命的哥哥的死亡。再往前,1837年,他毕业于著名的哈佛大学。<br>大自然是灵魂永恒的港湾。犹如母亲和情人,瓦尔登湖澄净的色彩让梭罗翻涌的内心一下子抵达了安静并狂热起来。安静的是他的情绪,狂热的是他的思绪,是他长久以来寻找的对话与表达。从1844年秋到1847年,短短一千多个日夜,瓦尔登湖拍岸的水声从梭罗心上流过,再一次流出就成了芬芳的墨香。<br>但这本书绝不是隐逸者说。事实上,它隐含的最重要的主题之一就是对自我的尊重与发现,对生命的真实与神圣的寻求。从这个意义上说,我们每一个人的内心都可能是一块小小的瓦尔登湖。只是,碌碌红尘里的你我总是在对碌碌红尘的房子、职务与收入等的追赶与算计中忽略了自己的内心。静静跟着梭罗的脚印走下去,你蛰居的生命就会豁然舒伸,你内心的瓦尔登湖就会为你打开美丽的四季。<br>发现并守住你的瓦尔登湖吧,我们每个人都可能是自己的梭罗。要知道,人间每走一个人,天上就会落一颗星。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式c语言-基本数据类型和结构</title>
      <link href="/2023/08/09/2023-8-9-20-05-54-Third/"/>
      <url>/2023/08/09/2023-8-9-20-05-54-Third/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式c语言【第一讲】-基本数据类型"><a href="#嵌入式c语言【第一讲】-基本数据类型" class="headerlink" title="嵌入式c语言【第一讲】-基本数据类型"></a>嵌入式c语言【第一讲】-基本数据类型</h1><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>嵌入式里常用c语言，如果是linux开发，也会常用c++和其他的一些语言，不过为了基础一点，从c语言开始记录。</p><p>嵌入式c语言开篇，常用作通过编程来控制硬件，当前编程语言很多，与硬件打交道的基本都是c语言，51，stm32的一些硬件，可以编写程序烧录到芯片内部的flash(存储区)来让硬件自己执行程序，达到你想要的效果。</p><p>当然当前编程语言太多了，不过我还是打算从c基础开篇开始记录下。</p><h2 id="前提环境"><a href="#前提环境" class="headerlink" title="前提环境"></a>前提环境</h2><p>我的建议是有虚拟机vmware或者是在linux系统下编程，如果不知道linux，可以从网上找vmware软件来下载，然后从ubuntu官网下载一个系统镜像安装到vmware中，具体操作步骤可以自行从网上搜索。当然如果你有云服务器也可以，只要是linux操作系统就行，因为涉及到编译等环境搭建很简单。</p><h2 id="c语言基本类型"><a href="#c语言基本类型" class="headerlink" title="c语言基本类型"></a>c语言基本类型</h2><p>在基本类型之前我要说明几点：</p><p><code>关键字</code>，编程语言都有所谓的关键字，关键字就是告诉机器你句话是什么意思，他好按照你给他的关键字来将你写好的程序编译成机器语言好去执行，机器语言就是只有机器能读懂的语言，也就是二进制格式，0和1，机器底层只能执行0和1，所以要按照你给的关键字将代码最终整理成0和1。</p><p>c语言的关键字有：</p><p>​<code>auto</code> ：声明自动变量</p><p>​ <code>break</code>：跳出当前循环</p><p>​ <code>case</code>：开关语句分支</p><p>​ <code>char</code>：声明字符型变量或函数返回值类型</p><p>​ <code>const</code> ：声明只读变量</p><p>​<code>continue</code>：结束当前循环，开始下一轮循环</p><p>​<code>default</code>：开关语句中的“默认”分支</p><p>​<code>do</code> ：循环语句的循环体</p><p>​ <code>double</code> ：声明双精度浮点型变量或函数返回值类型</p><p>​ <code>else</code> ：条件语句否定分支（与 if 连用）</p><p>​ <code>enum</code> ：声明枚举类型</p><p>​ <code>extern</code>：声明变量或函数是在其它文件或本文件的其他位置定义</p><p>​<code>float</code>：声明浮点型变量或函数返回值类型</p><p>​ <code>for</code>：一种循环语句</p><p>​<code>goto</code>：无条件跳转语句</p><p>​<code>if</code>：条件语句</p><p>​ <code>int</code>： 声明整型变量或函数</p><p>​ <code>long</code> ：声明长整型变量或函数返回值类型</p><p>​ <code>register</code>：声明寄存器变量</p><p>​ <code>return</code> ：子程序返回语句（可以带参数，也可不带参数）</p><p>​ <code>short</code> ：声明短整型变量或函数</p><p>​ <code>signed</code>：声明有符号类型变量或函数</p><p>​ <code>sizeof</code>：计算数据类型或变量长度（即所占字节数）</p><p>​<code>static</code> ：声明静态变量</p><p>​ <code>struct</code>：声明结构体类型</p><p>​ <code>switch</code> :用于开关语句</p><p>​ <code>typedef</code>：用以给数据类型取别名</p><p>​ <code>unsigned</code>：声明无符号类型变量或函数</p><p>​ <code>union</code>：声明共用体类型</p><p>​<code>void</code> ：声明函数无返回值或无参数，声明无类型指针</p><p>​ <code>volatile</code>：说明变量在程序执行中可被隐含地改变</p><p>​ <code>while</code> ：循环语句的循环条件</p><p>乍一看很多，其实常用的也就几个，循环语句使用while，for</p><p>判断使用：if，或者三目运算符，<strong>三目运算符</strong>到后边再讲。</p><p>还有条件多的情况下使用：switch case，比if速度要快。</p><p>还有基本的类型声明</p><pre><code>     1.整型：`int`</code></pre><p>​ 2.字符型：<code>char</code></p><p>​ 3.短整型：<code>short</code></p><p>​ 4.长整型：<code>long</code></p><p>​ 5.长长整型：<code>long long</code></p><p>​ 6.浮点型：<code>float</code></p><p>​ 7.双精度浮点型：<code>double</code></p><p>以上声明的数据类型都是有符号的，无符号的在前边声明<code>unsigned</code>。</p><p>例子：</p><p>​ 声明一个整型变量a：<strong>int a</strong>;</p><p>​ 一个字符类型变量b：<strong>char b</strong>;</p><p>​ 一个短整型变量c：<strong>short c</strong>;</p><p>等等，无符号类型就是在前边加上<code>unsigned</code>来修饰</p><p>​ 一个无符号整型变量a：<strong>unsigned int a</strong>;</p><p>​ 一个无符号字符类型变量b：<strong>unsigned char b</strong>;</p><p>​ 一个无符号短整型变量c：<strong>unsigned short c</strong>;</p><h2 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h2><p>有符号的意思是这个变量的空间的最高位，代表着该数是<strong>正数</strong>还是<strong>负数</strong></p><p>一个<code>int</code>类型的变量，它在程序空间里边占着四个字节的单位。</p><p>我们的机器，最底层内部结构其实是分布很多的0与1的小空间。这个小空间只有高与低，就像一个只能装一滴水的杯子，要么是空杯子<strong>0</strong>，要么就是装水的杯子(一滴水)<strong>1</strong>。这些空间(杯子)八个连在一起。</p><p><img src="/pic/note/note.jpg"></p><p><code>无符号</code>的意思就是这八个位组成的一个字节，他的大小范围就是从0<del>(2^8-1)的大小，也就是0</del>255，一共能表示256个数。它不能表示负数，毕竟没有符号。</p><p>当有符号的话，最高位就也就是如下图</p><p><img src="/pic/note/note2.jpg"></p><p>箭头所表示的最高位，它就与其他位区别开来，如果最高位为<strong>0</strong>，表示是个正数，如果这一位为<strong>1</strong>，表示整体就是一个负数，具体范围就是<code>-128</code><del><code>127</code>，不过这一个字节能表示的范围也是256个数，只不过相当于从<strong>0</strong></del><strong>255</strong>分割开了，取了其中的一半来当作负数。</p><p>在编程语言中，<strong>一个字节有8个bit位，bit位表示0或者1，这8个bit位组成一个字节，也就是我们常常定义一个char类型变量的时候的空间大小.</strong></p><p><code>char</code> <strong>一个字节</strong></p><p>范围：**-128~127**</p><p>无符号范围：<strong>0~255</strong></p><p><code>short</code><strong>两个字节</strong></p><p> <strong>-32768~32767</strong></p><p><strong>0~65535</strong></p><p><code>int</code><strong>四个字节</strong></p><p><strong>-2^15~2^15-1</strong></p><p><strong>0~2^32-1</strong></p><p><code>long</code> <strong>八个字节</strong></p><p>这是我们目前常用的。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值语句就是<code>=</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1000</span>;<span class="comment">//赋值a给1000</span></span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环命令"><a href="#循环命令" class="headerlink" title="循环命令"></a>循环命令</h3><p>循环语句使用<code>for</code>与<code>while</code></p><p><code>for(初始条件;临界条件;执行语句后的命令) &#123;循环执行的命令&#125;</code></p><p><code>while(判断条件)&#123;循环执行的命令&#125;</code></p><p>简单例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(a = <span class="number">0</span>; a&lt;<span class="number">10</span>; a++)<span class="comment">//循环10次执行中括号内的命令</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">20</span>)<span class="comment">//循环20次执行中括号内的命令，变量a要记得每次+1,不然造成死循环,只能靠break来跳出</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">a++;<span class="comment">//a = a + 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><p><code>break</code>是跳出循环，如果有循环嵌套的请款，只能跳出一层循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">while</span>(b&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ···</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//只能跳出当前while(b&lt;10)的循环，跳出之后回到while(a&lt;10)内执行的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><code>if</code>语句用来条件判断，通常使用的还有<strong>三目运算符</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)</span><br><span class="line">&#123;<span class="comment">/* if条件成立*/</span></span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/* if条件不成立执行下边的语句 */</span></span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>多个if-else判断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(d&lt;a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;a\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d&lt;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d&lt;c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d&lt;c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d最大&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上命令执行后最后进入的分支是第三个<code>if(d&lt;c)</code>的执行命令，打印输出”d&lt;c”</p><p><strong>注意</strong>：当你的<code>if-else</code>如果特别多的话，执行效率会很低，因为<strong>每次一个if条件不成立，他都会判断下一个if条件，知道最后进入if成立的语句才执行其内部的命令</strong>，像上边的<strong>四个if判断</strong>(在这里最后的else也可以看作是一个if判断)。<strong>“if语句内部的条件判断,是布尔类型，也就是<code>真``假</code>两种判断结果，如果if里边写成这样  if(a&#x3D;1) 编译器是会认为里边的条件为真，因为它里边并不是什么判断语句，而是赋值语句，这点要注意 ”</strong></p><p>在很多时候我们确实要用很多判断，如果条件可以我推荐使用<code>switch case</code>语句，或者把<code>switch case </code>与 <code>if -else</code>结合使用，也许能提高你程序的运行速度。</p><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><p>它的执行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = 0\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 1\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 2\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span><span class="number">&#x27;</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 10\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a为其他\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上执行的结果是<strong>a &#x3D; 10</strong>，相比使用<code>if-else</code>来说速度很快，如果是<code>if-else</code>的话，这个应该这样写了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 0\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = 10\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a为其他\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if判断到第11条也就是<code>else if (a == 10)</code>才能真正执行打印 <strong>a &#x3D; 10</strong>的语句，相比<code>switch-case</code>来说效率太低。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符分为<code>符号运算符</code>和<code>逻辑运算符</code></p><h3 id="符号运算符"><a href="#符号运算符" class="headerlink" title="符号运算符"></a>符号运算符</h3><p>常见的<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>这四个，加减乘除，<strong>注意，除法得到的只能是整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">3</span>,c;</span><br><span class="line">c = a / b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>最后打印结果为<code>c = 3</code></p><p><code>%</code>为取余，比如<code>10%3</code>，这个结果就是1，<code>15%6</code>，结果就是3，或者是<code>20%4</code>，结果就是0</p><p>除此之外，还有一些<code>位与运算</code>，</p><p>​与运算：<code>&amp;</code></p><p>​或运算：<code>|</code></p><p>​非运算：<code>~</code></p><p>​异或运算:<code>^</code></p><p>如果两个数进行与以上四种运算，那这两个数一定不会很复杂。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日月山</title>
      <link href="/2023/02/23/2023-2-26-14-11-03-First/"/>
      <url>/2023/02/23/2023-2-26-14-11-03-First/</url>
      
        <content type="html"><![CDATA[<h1 id="日月山"><a href="#日月山" class="headerlink" title="日月山"></a>日月山</h1><p>​长住西宁的朋友开车送我出来，一路往高处走。“有反应吗？”朋友问。“心跳有点快。”“乍来都这样。到日月山你反应会更明显。”朋友开车，把一首叫《鸿雁》的歌声音开得很大。<br>我有点心慌，但不是因为缺氧。我想此刻我妹妹一定有点心动过速，我感到了她的那种心慌。我们是孪生兄妹。她在北京，正准备嫁人结婚。她让我来日月山看一个人。我该对那个叫扎西的藏族小伙子说点啥呢？<br>        “你想说什么就说什么。”我妹妹说，“你要什么都不想说，就说，你是我哥。他会明白。”<br>我见过那个叫扎西的藏族小伙子的照片。他和我妹妹站在西宁街头，坐在青海湖边，站在布达拉宫脚下，坐在大昭寺前，每个人跷起一只脚独立于八角街边的大风里。在这些照片上，我妹妹吊在扎西的脖子上，张大嘴开心地笑，露出了好看的牙齿。帅帅的扎西头发长长的，笑得比较节制，像个康巴汉子。<br>​       他俩是在西宁那条著名的美食街遇上的，扎西买了一串硕大的烤羊肠递给她，我妹妹只吃了其中的一小截。第二天他们又在日月山碰到了。扎西是日月山最年轻的牦牛客，他牵的白牦牛两只角优雅地弯曲着，脑门上顶着一朵大红绸子扎成的花。扎西对我妹妹说：“上来吧，一分钱不要，想去哪儿都行。”扎西笑了，牙很白，像日月山顶峰上的雪。<br>​       后来，我妹妹想留在日月山下扎西家的小平房里。我爸妈说：肯定不行！旅游结个伴儿还可以，要结婚一块过日子，没戏。事实也如此，我妹妹不可能一辈子生活在缺氧的拉萨、西宁和日月山，她的心肺功能先天不好，还吃不了羊肉。我爸妈硬把她从青海的日月山下拽了回来。妹妹回来了，拉杆箱里的一部分行李还舍不得全拿出来。我妈把妹妹的心电图报告单抖得哗哗响，指着窗外的中关村大街：“还想走？走了你就不用再回来了！”<br>​       阳光不见了。天低下来，落下了雪。“怎么回事？这可是五月了！”我说。“谁说雪就得在正月里下？”朋友回答我，“你要待在这里，会发现六月照样下雪。”果真，雪越下越大，天地间一片苍茫。初夏走了，冬天跟着一场大雪杀了一个回马枪。车在世界屋脊上继续跑，高速公路像腰带一样打起了弯。“喏，”朋友说，“那就是日月山。”<br>​我把日月山想高了。我知道她是圣山、神山。我以为日月山一定壁立千仞险峻高拔，应该是奇峰迭起般的十万大山，事实上她就是比高原更高的隆起、隆起、再隆起，她的隆起和攀升安静、从容、柔和，有一种风起云涌但又漫不经心的力量。<br>​买了进景区的票，朋友让我把所有的衣服都穿上，风帽戴好，他就待在车里了。日月山他来几十回了。“看，那是日亭，那是月亭。当年文成公主赴吐蕃和亲，走到日月山，思乡心切，回望长安，把皇后送给她的日月宝镜拿出来照，竟在镜子里看见了京城长安的繁华盛景，且惊且喜且悲，情不自胜，宝镜脱手，摔成了两半。一半为日，一半为月，日月山就是这么来的。你看，那雕像就是文成公主，那块石头就是回望石。回头望长安，可怜无数山。”<br>​不知道文成公主嫁给松赞干布以后，是否习惯粗粝动荡的游牧生活。她喝得惯吐蕃的酒么？吃得惯带膻味的牛羊肉么？从长安到这里，千万里也，车辚辚，马萧萧，文成公主硬是走过来了。我用围巾围住鼻子和嘴，只剩一双眼睛看世界。好像整个日月山只有我一个游客。此外就是一个磕长头的藏族老人，走几步扑通跪倒，舒展开身体匍匐在雪地上，起身，走几步，再跪倒，匍匐。他的脸是一块静默的黑石头。<br>​我先沿着台阶往日亭上走，上两个台阶我就停一下，调整好呼吸的节奏再走。这个节奏是妹妹告诉我的，她说是扎西总结的经验，要不她那样的内地女孩，在青藏高原上早歇菜了。扎西的节奏很管用，但我在日亭边上没有找到扎西。早上我给扎西家里打过电话，他妈妈说扎西一大早就牵着牦牛带着干粮上山了。从那边下来，我又往月亭爬，一路留心山道上的活物。站在月亭边上，我才看见另一边的山道上站着一头牦牛。雪还在下，要不是牛头上的红绸子和牛背上色彩鲜艳的坐垫，那头白牦牛就被大雪遮蔽了。我又费力地在牦牛周围看了半天，才看见地上坐着一个人。他是最后的希望。日月山上此时不会再有第二个牦牛客了。在我走到他面前的十几分钟里，牦牛摇了两下头，甩了三次尾巴，他像文成公主雕像一样动都没动。<br>​我说：“兄弟，走两圈？”<br>​他抬起头，光头，没戴帽子，但我知道他就是扎西。他比我妹妹的照片里黑了一点，也老了一些，脸上出现了干燥的皱纹。<br>​“怎么走？”他问。<br>​“随便。走你最喜欢走的那条线。”<br>​我骑在牦牛上，他在左前方牵着缰绳。可能是出于习惯，因为一大早出门时天很好，他的衣服在风雪里看上去有点单。他的腰间缀着个阴刻雕花铜环，铜环下肯定没有流苏，这是我妹妹的风格。<br>​一头牛，两个人，我们孤零零地走在日月山的风雪里。好半晌，还是我用问话打破了沉默。<br>​“你是本地人？”“嗯。睁开眼睛看见的就是日月山。”“没想过去西宁？”“过去想过。”<br>​“现在呢？”“不想了。”“为什么？”“日月山好。”“那，北京呢？”<br>​他停下来，扭了半个头看我，好像我说的是外语。“北京？”他用方言说了这个词，笑了一声，“太远了。”<br>​沉默。<br>​“日月山好在哪儿？”我还是问出了这个问题。<br>​他停下来，想了想，说：“地老天荒。”<br>​终点到了。我不能再在牛背上待下去了。跳下牛背的时候我拉下围巾，露出完整的一张脸。按照扎西式节奏调整了呼吸之后，我才说：<br>​“你看我长得像谁？”“你自己啊。”<br>​“我的意思，你知道我是谁么？”<br>​他笑了笑，“一个游客。”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>说明</title>
      <link href="/2023/02/23/2023-3-21-22-42-33-Second/"/>
      <url>/2023/02/23/2023-3-21-22-42-33-Second/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h2><pre><code>从今天开始就不定期的更新博客了，说是博客，日志</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
